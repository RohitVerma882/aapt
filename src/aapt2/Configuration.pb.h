// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Configuration.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto

#include <cstdint>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Configuration_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Configuration_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Configuration_2eproto;
namespace aapt {
namespace pb {
class Configuration;
struct ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
}  // namespace pb
}  // namespace aapt
PROTOBUF_NAMESPACE_OPEN
template<> ::aapt::pb::Configuration* Arena::CreateMaybeMessage<::aapt::pb::Configuration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace aapt {
namespace pb {

enum Configuration_LayoutDirection : int {
  Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET = 0,
  Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR = 1,
  Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL = 2,
  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_LayoutDirection_IsValid(int value);
constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MIN = Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MAX = Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
constexpr int Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE = Configuration_LayoutDirection_LayoutDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_LayoutDirection_descriptor();
template<typename T>
inline const std::string& Configuration_LayoutDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_LayoutDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_LayoutDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_LayoutDirection_descriptor(), enum_t_value);
}
inline bool Configuration_LayoutDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_LayoutDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_LayoutDirection>(
    Configuration_LayoutDirection_descriptor(), name, value);
}
enum Configuration_ScreenLayoutSize : int {
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET = 0,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL = 1,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL = 2,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE = 3,
  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE = 4,
  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_ScreenLayoutSize_IsValid(int value);
constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
constexpr int Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE = Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutSize_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenLayoutSize_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenLayoutSize>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenLayoutSize_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenLayoutSize_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenLayoutSize_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenLayoutSize* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutSize>(
    Configuration_ScreenLayoutSize_descriptor(), name, value);
}
enum Configuration_ScreenLayoutLong : int {
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET = 0,
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG = 1,
  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG = 2,
  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_ScreenLayoutLong_IsValid(int value);
constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
constexpr int Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE = Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutLong_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenLayoutLong_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenLayoutLong>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenLayoutLong_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenLayoutLong_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenLayoutLong_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenLayoutLong* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutLong>(
    Configuration_ScreenLayoutLong_descriptor(), name, value);
}
enum Configuration_ScreenRound : int {
  Configuration_ScreenRound_SCREEN_ROUND_UNSET = 0,
  Configuration_ScreenRound_SCREEN_ROUND_ROUND = 1,
  Configuration_ScreenRound_SCREEN_ROUND_NOTROUND = 2,
  Configuration_ScreenRound_Configuration_ScreenRound_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_ScreenRound_Configuration_ScreenRound_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_ScreenRound_IsValid(int value);
constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MIN = Configuration_ScreenRound_SCREEN_ROUND_UNSET;
constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MAX = Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
constexpr int Configuration_ScreenRound_ScreenRound_ARRAYSIZE = Configuration_ScreenRound_ScreenRound_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenRound_descriptor();
template<typename T>
inline const std::string& Configuration_ScreenRound_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_ScreenRound>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_ScreenRound_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_ScreenRound_descriptor(), enum_t_value);
}
inline bool Configuration_ScreenRound_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenRound* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenRound>(
    Configuration_ScreenRound_descriptor(), name, value);
}
enum Configuration_WideColorGamut : int {
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET = 0,
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG = 1,
  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG = 2,
  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_WideColorGamut_IsValid(int value);
constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MIN = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MAX = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
constexpr int Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE = Configuration_WideColorGamut_WideColorGamut_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_WideColorGamut_descriptor();
template<typename T>
inline const std::string& Configuration_WideColorGamut_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_WideColorGamut>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_WideColorGamut_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_WideColorGamut_descriptor(), enum_t_value);
}
inline bool Configuration_WideColorGamut_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_WideColorGamut* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_WideColorGamut>(
    Configuration_WideColorGamut_descriptor(), name, value);
}
enum Configuration_Hdr : int {
  Configuration_Hdr_HDR_UNSET = 0,
  Configuration_Hdr_HDR_HIGHDR = 1,
  Configuration_Hdr_HDR_LOWDR = 2,
  Configuration_Hdr_Configuration_Hdr_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_Hdr_Configuration_Hdr_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_Hdr_IsValid(int value);
constexpr Configuration_Hdr Configuration_Hdr_Hdr_MIN = Configuration_Hdr_HDR_UNSET;
constexpr Configuration_Hdr Configuration_Hdr_Hdr_MAX = Configuration_Hdr_HDR_LOWDR;
constexpr int Configuration_Hdr_Hdr_ARRAYSIZE = Configuration_Hdr_Hdr_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Hdr_descriptor();
template<typename T>
inline const std::string& Configuration_Hdr_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Hdr>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Hdr_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Hdr_descriptor(), enum_t_value);
}
inline bool Configuration_Hdr_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Hdr* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Hdr>(
    Configuration_Hdr_descriptor(), name, value);
}
enum Configuration_Orientation : int {
  Configuration_Orientation_ORIENTATION_UNSET = 0,
  Configuration_Orientation_ORIENTATION_PORT = 1,
  Configuration_Orientation_ORIENTATION_LAND = 2,
  Configuration_Orientation_ORIENTATION_SQUARE = 3,
  Configuration_Orientation_Configuration_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_Orientation_Configuration_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_Orientation_IsValid(int value);
constexpr Configuration_Orientation Configuration_Orientation_Orientation_MIN = Configuration_Orientation_ORIENTATION_UNSET;
constexpr Configuration_Orientation Configuration_Orientation_Orientation_MAX = Configuration_Orientation_ORIENTATION_SQUARE;
constexpr int Configuration_Orientation_Orientation_ARRAYSIZE = Configuration_Orientation_Orientation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Orientation_descriptor();
template<typename T>
inline const std::string& Configuration_Orientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Orientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Orientation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Orientation_descriptor(), enum_t_value);
}
inline bool Configuration_Orientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Orientation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Orientation>(
    Configuration_Orientation_descriptor(), name, value);
}
enum Configuration_UiModeType : int {
  Configuration_UiModeType_UI_MODE_TYPE_UNSET = 0,
  Configuration_UiModeType_UI_MODE_TYPE_NORMAL = 1,
  Configuration_UiModeType_UI_MODE_TYPE_DESK = 2,
  Configuration_UiModeType_UI_MODE_TYPE_CAR = 3,
  Configuration_UiModeType_UI_MODE_TYPE_TELEVISION = 4,
  Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE = 5,
  Configuration_UiModeType_UI_MODE_TYPE_WATCH = 6,
  Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET = 7,
  Configuration_UiModeType_Configuration_UiModeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_UiModeType_Configuration_UiModeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_UiModeType_IsValid(int value);
constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MIN = Configuration_UiModeType_UI_MODE_TYPE_UNSET;
constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MAX = Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
constexpr int Configuration_UiModeType_UiModeType_ARRAYSIZE = Configuration_UiModeType_UiModeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeType_descriptor();
template<typename T>
inline const std::string& Configuration_UiModeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_UiModeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_UiModeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_UiModeType_descriptor(), enum_t_value);
}
inline bool Configuration_UiModeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_UiModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeType>(
    Configuration_UiModeType_descriptor(), name, value);
}
enum Configuration_UiModeNight : int {
  Configuration_UiModeNight_UI_MODE_NIGHT_UNSET = 0,
  Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT = 1,
  Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT = 2,
  Configuration_UiModeNight_Configuration_UiModeNight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_UiModeNight_Configuration_UiModeNight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_UiModeNight_IsValid(int value);
constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MIN = Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MAX = Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
constexpr int Configuration_UiModeNight_UiModeNight_ARRAYSIZE = Configuration_UiModeNight_UiModeNight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeNight_descriptor();
template<typename T>
inline const std::string& Configuration_UiModeNight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_UiModeNight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_UiModeNight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_UiModeNight_descriptor(), enum_t_value);
}
inline bool Configuration_UiModeNight_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_UiModeNight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeNight>(
    Configuration_UiModeNight_descriptor(), name, value);
}
enum Configuration_Touchscreen : int {
  Configuration_Touchscreen_TOUCHSCREEN_UNSET = 0,
  Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH = 1,
  Configuration_Touchscreen_TOUCHSCREEN_STYLUS = 2,
  Configuration_Touchscreen_TOUCHSCREEN_FINGER = 3,
  Configuration_Touchscreen_Configuration_Touchscreen_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_Touchscreen_Configuration_Touchscreen_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_Touchscreen_IsValid(int value);
constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MIN = Configuration_Touchscreen_TOUCHSCREEN_UNSET;
constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MAX = Configuration_Touchscreen_TOUCHSCREEN_FINGER;
constexpr int Configuration_Touchscreen_Touchscreen_ARRAYSIZE = Configuration_Touchscreen_Touchscreen_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Touchscreen_descriptor();
template<typename T>
inline const std::string& Configuration_Touchscreen_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Touchscreen>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Touchscreen_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Touchscreen_descriptor(), enum_t_value);
}
inline bool Configuration_Touchscreen_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Touchscreen* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Touchscreen>(
    Configuration_Touchscreen_descriptor(), name, value);
}
enum Configuration_KeysHidden : int {
  Configuration_KeysHidden_KEYS_HIDDEN_UNSET = 0,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED = 1,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN = 2,
  Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT = 3,
  Configuration_KeysHidden_Configuration_KeysHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_KeysHidden_Configuration_KeysHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_KeysHidden_IsValid(int value);
constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MIN = Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MAX = Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
constexpr int Configuration_KeysHidden_KeysHidden_ARRAYSIZE = Configuration_KeysHidden_KeysHidden_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_KeysHidden_descriptor();
template<typename T>
inline const std::string& Configuration_KeysHidden_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_KeysHidden>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_KeysHidden_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_KeysHidden_descriptor(), enum_t_value);
}
inline bool Configuration_KeysHidden_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_KeysHidden* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_KeysHidden>(
    Configuration_KeysHidden_descriptor(), name, value);
}
enum Configuration_Keyboard : int {
  Configuration_Keyboard_KEYBOARD_UNSET = 0,
  Configuration_Keyboard_KEYBOARD_NOKEYS = 1,
  Configuration_Keyboard_KEYBOARD_QWERTY = 2,
  Configuration_Keyboard_KEYBOARD_TWELVEKEY = 3,
  Configuration_Keyboard_Configuration_Keyboard_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_Keyboard_Configuration_Keyboard_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_Keyboard_IsValid(int value);
constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MIN = Configuration_Keyboard_KEYBOARD_UNSET;
constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MAX = Configuration_Keyboard_KEYBOARD_TWELVEKEY;
constexpr int Configuration_Keyboard_Keyboard_ARRAYSIZE = Configuration_Keyboard_Keyboard_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Keyboard_descriptor();
template<typename T>
inline const std::string& Configuration_Keyboard_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Keyboard>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Keyboard_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Keyboard_descriptor(), enum_t_value);
}
inline bool Configuration_Keyboard_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Keyboard* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Keyboard>(
    Configuration_Keyboard_descriptor(), name, value);
}
enum Configuration_NavHidden : int {
  Configuration_NavHidden_NAV_HIDDEN_UNSET = 0,
  Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED = 1,
  Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN = 2,
  Configuration_NavHidden_Configuration_NavHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_NavHidden_Configuration_NavHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_NavHidden_IsValid(int value);
constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MIN = Configuration_NavHidden_NAV_HIDDEN_UNSET;
constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MAX = Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
constexpr int Configuration_NavHidden_NavHidden_ARRAYSIZE = Configuration_NavHidden_NavHidden_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_NavHidden_descriptor();
template<typename T>
inline const std::string& Configuration_NavHidden_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_NavHidden>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_NavHidden_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_NavHidden_descriptor(), enum_t_value);
}
inline bool Configuration_NavHidden_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_NavHidden* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_NavHidden>(
    Configuration_NavHidden_descriptor(), name, value);
}
enum Configuration_Navigation : int {
  Configuration_Navigation_NAVIGATION_UNSET = 0,
  Configuration_Navigation_NAVIGATION_NONAV = 1,
  Configuration_Navigation_NAVIGATION_DPAD = 2,
  Configuration_Navigation_NAVIGATION_TRACKBALL = 3,
  Configuration_Navigation_NAVIGATION_WHEEL = 4,
  Configuration_Navigation_Configuration_Navigation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Configuration_Navigation_Configuration_Navigation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Configuration_Navigation_IsValid(int value);
constexpr Configuration_Navigation Configuration_Navigation_Navigation_MIN = Configuration_Navigation_NAVIGATION_UNSET;
constexpr Configuration_Navigation Configuration_Navigation_Navigation_MAX = Configuration_Navigation_NAVIGATION_WHEEL;
constexpr int Configuration_Navigation_Navigation_ARRAYSIZE = Configuration_Navigation_Navigation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Navigation_descriptor();
template<typename T>
inline const std::string& Configuration_Navigation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Configuration_Navigation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Configuration_Navigation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Configuration_Navigation_descriptor(), enum_t_value);
}
inline bool Configuration_Navigation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Navigation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Navigation>(
    Configuration_Navigation_descriptor(), name, value);
}
// ===================================================================

class Configuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Configuration) */ {
 public:
  inline Configuration() : Configuration(nullptr) {}
  ~Configuration() override;
  explicit PROTOBUF_CONSTEXPR Configuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  Configuration* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Configuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Configuration& from) {
    Configuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Configuration";
  }
  protected:
  explicit Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Configuration_LayoutDirection LayoutDirection;
  static constexpr LayoutDirection LAYOUT_DIRECTION_UNSET =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
  static constexpr LayoutDirection LAYOUT_DIRECTION_LTR =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR;
  static constexpr LayoutDirection LAYOUT_DIRECTION_RTL =
    Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
  static inline bool LayoutDirection_IsValid(int value) {
    return Configuration_LayoutDirection_IsValid(value);
  }
  static constexpr LayoutDirection LayoutDirection_MIN =
    Configuration_LayoutDirection_LayoutDirection_MIN;
  static constexpr LayoutDirection LayoutDirection_MAX =
    Configuration_LayoutDirection_LayoutDirection_MAX;
  static constexpr int LayoutDirection_ARRAYSIZE =
    Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LayoutDirection_descriptor() {
    return Configuration_LayoutDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& LayoutDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LayoutDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LayoutDirection_Name.");
    return Configuration_LayoutDirection_Name(enum_t_value);
  }
  static inline bool LayoutDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LayoutDirection* value) {
    return Configuration_LayoutDirection_Parse(name, value);
  }

  typedef Configuration_ScreenLayoutSize ScreenLayoutSize;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_UNSET =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_SMALL =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_NORMAL =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_LARGE =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE;
  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_XLARGE =
    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
  static inline bool ScreenLayoutSize_IsValid(int value) {
    return Configuration_ScreenLayoutSize_IsValid(value);
  }
  static constexpr ScreenLayoutSize ScreenLayoutSize_MIN =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN;
  static constexpr ScreenLayoutSize ScreenLayoutSize_MAX =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX;
  static constexpr int ScreenLayoutSize_ARRAYSIZE =
    Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenLayoutSize_descriptor() {
    return Configuration_ScreenLayoutSize_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenLayoutSize_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenLayoutSize>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenLayoutSize_Name.");
    return Configuration_ScreenLayoutSize_Name(enum_t_value);
  }
  static inline bool ScreenLayoutSize_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScreenLayoutSize* value) {
    return Configuration_ScreenLayoutSize_Parse(name, value);
  }

  typedef Configuration_ScreenLayoutLong ScreenLayoutLong;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_UNSET =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_LONG =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG;
  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_NOTLONG =
    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
  static inline bool ScreenLayoutLong_IsValid(int value) {
    return Configuration_ScreenLayoutLong_IsValid(value);
  }
  static constexpr ScreenLayoutLong ScreenLayoutLong_MIN =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN;
  static constexpr ScreenLayoutLong ScreenLayoutLong_MAX =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX;
  static constexpr int ScreenLayoutLong_ARRAYSIZE =
    Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenLayoutLong_descriptor() {
    return Configuration_ScreenLayoutLong_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenLayoutLong_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenLayoutLong>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenLayoutLong_Name.");
    return Configuration_ScreenLayoutLong_Name(enum_t_value);
  }
  static inline bool ScreenLayoutLong_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScreenLayoutLong* value) {
    return Configuration_ScreenLayoutLong_Parse(name, value);
  }

  typedef Configuration_ScreenRound ScreenRound;
  static constexpr ScreenRound SCREEN_ROUND_UNSET =
    Configuration_ScreenRound_SCREEN_ROUND_UNSET;
  static constexpr ScreenRound SCREEN_ROUND_ROUND =
    Configuration_ScreenRound_SCREEN_ROUND_ROUND;
  static constexpr ScreenRound SCREEN_ROUND_NOTROUND =
    Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
  static inline bool ScreenRound_IsValid(int value) {
    return Configuration_ScreenRound_IsValid(value);
  }
  static constexpr ScreenRound ScreenRound_MIN =
    Configuration_ScreenRound_ScreenRound_MIN;
  static constexpr ScreenRound ScreenRound_MAX =
    Configuration_ScreenRound_ScreenRound_MAX;
  static constexpr int ScreenRound_ARRAYSIZE =
    Configuration_ScreenRound_ScreenRound_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScreenRound_descriptor() {
    return Configuration_ScreenRound_descriptor();
  }
  template<typename T>
  static inline const std::string& ScreenRound_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenRound>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenRound_Name.");
    return Configuration_ScreenRound_Name(enum_t_value);
  }
  static inline bool ScreenRound_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScreenRound* value) {
    return Configuration_ScreenRound_Parse(name, value);
  }

  typedef Configuration_WideColorGamut WideColorGamut;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_UNSET =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_WIDECG =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG;
  static constexpr WideColorGamut WIDE_COLOR_GAMUT_NOWIDECG =
    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
  static inline bool WideColorGamut_IsValid(int value) {
    return Configuration_WideColorGamut_IsValid(value);
  }
  static constexpr WideColorGamut WideColorGamut_MIN =
    Configuration_WideColorGamut_WideColorGamut_MIN;
  static constexpr WideColorGamut WideColorGamut_MAX =
    Configuration_WideColorGamut_WideColorGamut_MAX;
  static constexpr int WideColorGamut_ARRAYSIZE =
    Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WideColorGamut_descriptor() {
    return Configuration_WideColorGamut_descriptor();
  }
  template<typename T>
  static inline const std::string& WideColorGamut_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WideColorGamut>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WideColorGamut_Name.");
    return Configuration_WideColorGamut_Name(enum_t_value);
  }
  static inline bool WideColorGamut_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WideColorGamut* value) {
    return Configuration_WideColorGamut_Parse(name, value);
  }

  typedef Configuration_Hdr Hdr;
  static constexpr Hdr HDR_UNSET =
    Configuration_Hdr_HDR_UNSET;
  static constexpr Hdr HDR_HIGHDR =
    Configuration_Hdr_HDR_HIGHDR;
  static constexpr Hdr HDR_LOWDR =
    Configuration_Hdr_HDR_LOWDR;
  static inline bool Hdr_IsValid(int value) {
    return Configuration_Hdr_IsValid(value);
  }
  static constexpr Hdr Hdr_MIN =
    Configuration_Hdr_Hdr_MIN;
  static constexpr Hdr Hdr_MAX =
    Configuration_Hdr_Hdr_MAX;
  static constexpr int Hdr_ARRAYSIZE =
    Configuration_Hdr_Hdr_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Hdr_descriptor() {
    return Configuration_Hdr_descriptor();
  }
  template<typename T>
  static inline const std::string& Hdr_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Hdr>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Hdr_Name.");
    return Configuration_Hdr_Name(enum_t_value);
  }
  static inline bool Hdr_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Hdr* value) {
    return Configuration_Hdr_Parse(name, value);
  }

  typedef Configuration_Orientation Orientation;
  static constexpr Orientation ORIENTATION_UNSET =
    Configuration_Orientation_ORIENTATION_UNSET;
  static constexpr Orientation ORIENTATION_PORT =
    Configuration_Orientation_ORIENTATION_PORT;
  static constexpr Orientation ORIENTATION_LAND =
    Configuration_Orientation_ORIENTATION_LAND;
  static constexpr Orientation ORIENTATION_SQUARE =
    Configuration_Orientation_ORIENTATION_SQUARE;
  static inline bool Orientation_IsValid(int value) {
    return Configuration_Orientation_IsValid(value);
  }
  static constexpr Orientation Orientation_MIN =
    Configuration_Orientation_Orientation_MIN;
  static constexpr Orientation Orientation_MAX =
    Configuration_Orientation_Orientation_MAX;
  static constexpr int Orientation_ARRAYSIZE =
    Configuration_Orientation_Orientation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Orientation_descriptor() {
    return Configuration_Orientation_descriptor();
  }
  template<typename T>
  static inline const std::string& Orientation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Orientation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Orientation_Name.");
    return Configuration_Orientation_Name(enum_t_value);
  }
  static inline bool Orientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Orientation* value) {
    return Configuration_Orientation_Parse(name, value);
  }

  typedef Configuration_UiModeType UiModeType;
  static constexpr UiModeType UI_MODE_TYPE_UNSET =
    Configuration_UiModeType_UI_MODE_TYPE_UNSET;
  static constexpr UiModeType UI_MODE_TYPE_NORMAL =
    Configuration_UiModeType_UI_MODE_TYPE_NORMAL;
  static constexpr UiModeType UI_MODE_TYPE_DESK =
    Configuration_UiModeType_UI_MODE_TYPE_DESK;
  static constexpr UiModeType UI_MODE_TYPE_CAR =
    Configuration_UiModeType_UI_MODE_TYPE_CAR;
  static constexpr UiModeType UI_MODE_TYPE_TELEVISION =
    Configuration_UiModeType_UI_MODE_TYPE_TELEVISION;
  static constexpr UiModeType UI_MODE_TYPE_APPLIANCE =
    Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE;
  static constexpr UiModeType UI_MODE_TYPE_WATCH =
    Configuration_UiModeType_UI_MODE_TYPE_WATCH;
  static constexpr UiModeType UI_MODE_TYPE_VRHEADSET =
    Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
  static inline bool UiModeType_IsValid(int value) {
    return Configuration_UiModeType_IsValid(value);
  }
  static constexpr UiModeType UiModeType_MIN =
    Configuration_UiModeType_UiModeType_MIN;
  static constexpr UiModeType UiModeType_MAX =
    Configuration_UiModeType_UiModeType_MAX;
  static constexpr int UiModeType_ARRAYSIZE =
    Configuration_UiModeType_UiModeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UiModeType_descriptor() {
    return Configuration_UiModeType_descriptor();
  }
  template<typename T>
  static inline const std::string& UiModeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UiModeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UiModeType_Name.");
    return Configuration_UiModeType_Name(enum_t_value);
  }
  static inline bool UiModeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UiModeType* value) {
    return Configuration_UiModeType_Parse(name, value);
  }

  typedef Configuration_UiModeNight UiModeNight;
  static constexpr UiModeNight UI_MODE_NIGHT_UNSET =
    Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
  static constexpr UiModeNight UI_MODE_NIGHT_NIGHT =
    Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT;
  static constexpr UiModeNight UI_MODE_NIGHT_NOTNIGHT =
    Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
  static inline bool UiModeNight_IsValid(int value) {
    return Configuration_UiModeNight_IsValid(value);
  }
  static constexpr UiModeNight UiModeNight_MIN =
    Configuration_UiModeNight_UiModeNight_MIN;
  static constexpr UiModeNight UiModeNight_MAX =
    Configuration_UiModeNight_UiModeNight_MAX;
  static constexpr int UiModeNight_ARRAYSIZE =
    Configuration_UiModeNight_UiModeNight_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UiModeNight_descriptor() {
    return Configuration_UiModeNight_descriptor();
  }
  template<typename T>
  static inline const std::string& UiModeNight_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UiModeNight>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UiModeNight_Name.");
    return Configuration_UiModeNight_Name(enum_t_value);
  }
  static inline bool UiModeNight_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UiModeNight* value) {
    return Configuration_UiModeNight_Parse(name, value);
  }

  typedef Configuration_Touchscreen Touchscreen;
  static constexpr Touchscreen TOUCHSCREEN_UNSET =
    Configuration_Touchscreen_TOUCHSCREEN_UNSET;
  static constexpr Touchscreen TOUCHSCREEN_NOTOUCH =
    Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH;
  static constexpr Touchscreen TOUCHSCREEN_STYLUS =
    Configuration_Touchscreen_TOUCHSCREEN_STYLUS;
  static constexpr Touchscreen TOUCHSCREEN_FINGER =
    Configuration_Touchscreen_TOUCHSCREEN_FINGER;
  static inline bool Touchscreen_IsValid(int value) {
    return Configuration_Touchscreen_IsValid(value);
  }
  static constexpr Touchscreen Touchscreen_MIN =
    Configuration_Touchscreen_Touchscreen_MIN;
  static constexpr Touchscreen Touchscreen_MAX =
    Configuration_Touchscreen_Touchscreen_MAX;
  static constexpr int Touchscreen_ARRAYSIZE =
    Configuration_Touchscreen_Touchscreen_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Touchscreen_descriptor() {
    return Configuration_Touchscreen_descriptor();
  }
  template<typename T>
  static inline const std::string& Touchscreen_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Touchscreen>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Touchscreen_Name.");
    return Configuration_Touchscreen_Name(enum_t_value);
  }
  static inline bool Touchscreen_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Touchscreen* value) {
    return Configuration_Touchscreen_Parse(name, value);
  }

  typedef Configuration_KeysHidden KeysHidden;
  static constexpr KeysHidden KEYS_HIDDEN_UNSET =
    Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSEXPOSED =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSHIDDEN =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN;
  static constexpr KeysHidden KEYS_HIDDEN_KEYSSOFT =
    Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
  static inline bool KeysHidden_IsValid(int value) {
    return Configuration_KeysHidden_IsValid(value);
  }
  static constexpr KeysHidden KeysHidden_MIN =
    Configuration_KeysHidden_KeysHidden_MIN;
  static constexpr KeysHidden KeysHidden_MAX =
    Configuration_KeysHidden_KeysHidden_MAX;
  static constexpr int KeysHidden_ARRAYSIZE =
    Configuration_KeysHidden_KeysHidden_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KeysHidden_descriptor() {
    return Configuration_KeysHidden_descriptor();
  }
  template<typename T>
  static inline const std::string& KeysHidden_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeysHidden>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeysHidden_Name.");
    return Configuration_KeysHidden_Name(enum_t_value);
  }
  static inline bool KeysHidden_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KeysHidden* value) {
    return Configuration_KeysHidden_Parse(name, value);
  }

  typedef Configuration_Keyboard Keyboard;
  static constexpr Keyboard KEYBOARD_UNSET =
    Configuration_Keyboard_KEYBOARD_UNSET;
  static constexpr Keyboard KEYBOARD_NOKEYS =
    Configuration_Keyboard_KEYBOARD_NOKEYS;
  static constexpr Keyboard KEYBOARD_QWERTY =
    Configuration_Keyboard_KEYBOARD_QWERTY;
  static constexpr Keyboard KEYBOARD_TWELVEKEY =
    Configuration_Keyboard_KEYBOARD_TWELVEKEY;
  static inline bool Keyboard_IsValid(int value) {
    return Configuration_Keyboard_IsValid(value);
  }
  static constexpr Keyboard Keyboard_MIN =
    Configuration_Keyboard_Keyboard_MIN;
  static constexpr Keyboard Keyboard_MAX =
    Configuration_Keyboard_Keyboard_MAX;
  static constexpr int Keyboard_ARRAYSIZE =
    Configuration_Keyboard_Keyboard_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Keyboard_descriptor() {
    return Configuration_Keyboard_descriptor();
  }
  template<typename T>
  static inline const std::string& Keyboard_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Keyboard>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Keyboard_Name.");
    return Configuration_Keyboard_Name(enum_t_value);
  }
  static inline bool Keyboard_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Keyboard* value) {
    return Configuration_Keyboard_Parse(name, value);
  }

  typedef Configuration_NavHidden NavHidden;
  static constexpr NavHidden NAV_HIDDEN_UNSET =
    Configuration_NavHidden_NAV_HIDDEN_UNSET;
  static constexpr NavHidden NAV_HIDDEN_NAVEXPOSED =
    Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED;
  static constexpr NavHidden NAV_HIDDEN_NAVHIDDEN =
    Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
  static inline bool NavHidden_IsValid(int value) {
    return Configuration_NavHidden_IsValid(value);
  }
  static constexpr NavHidden NavHidden_MIN =
    Configuration_NavHidden_NavHidden_MIN;
  static constexpr NavHidden NavHidden_MAX =
    Configuration_NavHidden_NavHidden_MAX;
  static constexpr int NavHidden_ARRAYSIZE =
    Configuration_NavHidden_NavHidden_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NavHidden_descriptor() {
    return Configuration_NavHidden_descriptor();
  }
  template<typename T>
  static inline const std::string& NavHidden_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NavHidden>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NavHidden_Name.");
    return Configuration_NavHidden_Name(enum_t_value);
  }
  static inline bool NavHidden_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NavHidden* value) {
    return Configuration_NavHidden_Parse(name, value);
  }

  typedef Configuration_Navigation Navigation;
  static constexpr Navigation NAVIGATION_UNSET =
    Configuration_Navigation_NAVIGATION_UNSET;
  static constexpr Navigation NAVIGATION_NONAV =
    Configuration_Navigation_NAVIGATION_NONAV;
  static constexpr Navigation NAVIGATION_DPAD =
    Configuration_Navigation_NAVIGATION_DPAD;
  static constexpr Navigation NAVIGATION_TRACKBALL =
    Configuration_Navigation_NAVIGATION_TRACKBALL;
  static constexpr Navigation NAVIGATION_WHEEL =
    Configuration_Navigation_NAVIGATION_WHEEL;
  static inline bool Navigation_IsValid(int value) {
    return Configuration_Navigation_IsValid(value);
  }
  static constexpr Navigation Navigation_MIN =
    Configuration_Navigation_Navigation_MIN;
  static constexpr Navigation Navigation_MAX =
    Configuration_Navigation_Navigation_MAX;
  static constexpr int Navigation_ARRAYSIZE =
    Configuration_Navigation_Navigation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Navigation_descriptor() {
    return Configuration_Navigation_descriptor();
  }
  template<typename T>
  static inline const std::string& Navigation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Navigation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Navigation_Name.");
    return Configuration_Navigation_Name(enum_t_value);
  }
  static inline bool Navigation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Navigation* value) {
    return Configuration_Navigation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 3,
    kProductFieldNumber = 25,
    kMccFieldNumber = 1,
    kMncFieldNumber = 2,
    kLayoutDirectionFieldNumber = 4,
    kScreenWidthFieldNumber = 5,
    kScreenHeightFieldNumber = 6,
    kScreenWidthDpFieldNumber = 7,
    kScreenHeightDpFieldNumber = 8,
    kSmallestScreenWidthDpFieldNumber = 9,
    kScreenLayoutSizeFieldNumber = 10,
    kScreenLayoutLongFieldNumber = 11,
    kScreenRoundFieldNumber = 12,
    kWideColorGamutFieldNumber = 13,
    kHdrFieldNumber = 14,
    kOrientationFieldNumber = 15,
    kUiModeTypeFieldNumber = 16,
    kUiModeNightFieldNumber = 17,
    kDensityFieldNumber = 18,
    kTouchscreenFieldNumber = 19,
    kKeysHiddenFieldNumber = 20,
    kKeyboardFieldNumber = 21,
    kNavHiddenFieldNumber = 22,
    kNavigationFieldNumber = 23,
    kSdkVersionFieldNumber = 24,
  };
  // string locale = 3;
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // string product = 25;
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // uint32 mcc = 1;
  void clear_mcc();
  ::uint32_t mcc() const;
  void set_mcc(::uint32_t value);
  private:
  ::uint32_t _internal_mcc() const;
  void _internal_set_mcc(::uint32_t value);
  public:

  // uint32 mnc = 2;
  void clear_mnc();
  ::uint32_t mnc() const;
  void set_mnc(::uint32_t value);
  private:
  ::uint32_t _internal_mnc() const;
  void _internal_set_mnc(::uint32_t value);
  public:

  // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
  void clear_layout_direction();
  ::aapt::pb::Configuration_LayoutDirection layout_direction() const;
  void set_layout_direction(::aapt::pb::Configuration_LayoutDirection value);
  private:
  ::aapt::pb::Configuration_LayoutDirection _internal_layout_direction() const;
  void _internal_set_layout_direction(::aapt::pb::Configuration_LayoutDirection value);
  public:

  // uint32 screen_width = 5;
  void clear_screen_width();
  ::uint32_t screen_width() const;
  void set_screen_width(::uint32_t value);
  private:
  ::uint32_t _internal_screen_width() const;
  void _internal_set_screen_width(::uint32_t value);
  public:

  // uint32 screen_height = 6;
  void clear_screen_height();
  ::uint32_t screen_height() const;
  void set_screen_height(::uint32_t value);
  private:
  ::uint32_t _internal_screen_height() const;
  void _internal_set_screen_height(::uint32_t value);
  public:

  // uint32 screen_width_dp = 7;
  void clear_screen_width_dp();
  ::uint32_t screen_width_dp() const;
  void set_screen_width_dp(::uint32_t value);
  private:
  ::uint32_t _internal_screen_width_dp() const;
  void _internal_set_screen_width_dp(::uint32_t value);
  public:

  // uint32 screen_height_dp = 8;
  void clear_screen_height_dp();
  ::uint32_t screen_height_dp() const;
  void set_screen_height_dp(::uint32_t value);
  private:
  ::uint32_t _internal_screen_height_dp() const;
  void _internal_set_screen_height_dp(::uint32_t value);
  public:

  // uint32 smallest_screen_width_dp = 9;
  void clear_smallest_screen_width_dp();
  ::uint32_t smallest_screen_width_dp() const;
  void set_smallest_screen_width_dp(::uint32_t value);
  private:
  ::uint32_t _internal_smallest_screen_width_dp() const;
  void _internal_set_smallest_screen_width_dp(::uint32_t value);
  public:

  // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
  void clear_screen_layout_size();
  ::aapt::pb::Configuration_ScreenLayoutSize screen_layout_size() const;
  void set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value);
  private:
  ::aapt::pb::Configuration_ScreenLayoutSize _internal_screen_layout_size() const;
  void _internal_set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value);
  public:

  // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
  void clear_screen_layout_long();
  ::aapt::pb::Configuration_ScreenLayoutLong screen_layout_long() const;
  void set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value);
  private:
  ::aapt::pb::Configuration_ScreenLayoutLong _internal_screen_layout_long() const;
  void _internal_set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value);
  public:

  // .aapt.pb.Configuration.ScreenRound screen_round = 12;
  void clear_screen_round();
  ::aapt::pb::Configuration_ScreenRound screen_round() const;
  void set_screen_round(::aapt::pb::Configuration_ScreenRound value);
  private:
  ::aapt::pb::Configuration_ScreenRound _internal_screen_round() const;
  void _internal_set_screen_round(::aapt::pb::Configuration_ScreenRound value);
  public:

  // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
  void clear_wide_color_gamut();
  ::aapt::pb::Configuration_WideColorGamut wide_color_gamut() const;
  void set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value);
  private:
  ::aapt::pb::Configuration_WideColorGamut _internal_wide_color_gamut() const;
  void _internal_set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value);
  public:

  // .aapt.pb.Configuration.Hdr hdr = 14;
  void clear_hdr();
  ::aapt::pb::Configuration_Hdr hdr() const;
  void set_hdr(::aapt::pb::Configuration_Hdr value);
  private:
  ::aapt::pb::Configuration_Hdr _internal_hdr() const;
  void _internal_set_hdr(::aapt::pb::Configuration_Hdr value);
  public:

  // .aapt.pb.Configuration.Orientation orientation = 15;
  void clear_orientation();
  ::aapt::pb::Configuration_Orientation orientation() const;
  void set_orientation(::aapt::pb::Configuration_Orientation value);
  private:
  ::aapt::pb::Configuration_Orientation _internal_orientation() const;
  void _internal_set_orientation(::aapt::pb::Configuration_Orientation value);
  public:

  // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
  void clear_ui_mode_type();
  ::aapt::pb::Configuration_UiModeType ui_mode_type() const;
  void set_ui_mode_type(::aapt::pb::Configuration_UiModeType value);
  private:
  ::aapt::pb::Configuration_UiModeType _internal_ui_mode_type() const;
  void _internal_set_ui_mode_type(::aapt::pb::Configuration_UiModeType value);
  public:

  // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
  void clear_ui_mode_night();
  ::aapt::pb::Configuration_UiModeNight ui_mode_night() const;
  void set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value);
  private:
  ::aapt::pb::Configuration_UiModeNight _internal_ui_mode_night() const;
  void _internal_set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value);
  public:

  // uint32 density = 18;
  void clear_density();
  ::uint32_t density() const;
  void set_density(::uint32_t value);
  private:
  ::uint32_t _internal_density() const;
  void _internal_set_density(::uint32_t value);
  public:

  // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
  void clear_touchscreen();
  ::aapt::pb::Configuration_Touchscreen touchscreen() const;
  void set_touchscreen(::aapt::pb::Configuration_Touchscreen value);
  private:
  ::aapt::pb::Configuration_Touchscreen _internal_touchscreen() const;
  void _internal_set_touchscreen(::aapt::pb::Configuration_Touchscreen value);
  public:

  // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
  void clear_keys_hidden();
  ::aapt::pb::Configuration_KeysHidden keys_hidden() const;
  void set_keys_hidden(::aapt::pb::Configuration_KeysHidden value);
  private:
  ::aapt::pb::Configuration_KeysHidden _internal_keys_hidden() const;
  void _internal_set_keys_hidden(::aapt::pb::Configuration_KeysHidden value);
  public:

  // .aapt.pb.Configuration.Keyboard keyboard = 21;
  void clear_keyboard();
  ::aapt::pb::Configuration_Keyboard keyboard() const;
  void set_keyboard(::aapt::pb::Configuration_Keyboard value);
  private:
  ::aapt::pb::Configuration_Keyboard _internal_keyboard() const;
  void _internal_set_keyboard(::aapt::pb::Configuration_Keyboard value);
  public:

  // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
  void clear_nav_hidden();
  ::aapt::pb::Configuration_NavHidden nav_hidden() const;
  void set_nav_hidden(::aapt::pb::Configuration_NavHidden value);
  private:
  ::aapt::pb::Configuration_NavHidden _internal_nav_hidden() const;
  void _internal_set_nav_hidden(::aapt::pb::Configuration_NavHidden value);
  public:

  // .aapt.pb.Configuration.Navigation navigation = 23;
  void clear_navigation();
  ::aapt::pb::Configuration_Navigation navigation() const;
  void set_navigation(::aapt::pb::Configuration_Navigation value);
  private:
  ::aapt::pb::Configuration_Navigation _internal_navigation() const;
  void _internal_set_navigation(::aapt::pb::Configuration_Navigation value);
  public:

  // uint32 sdk_version = 24;
  void clear_sdk_version();
  ::uint32_t sdk_version() const;
  void set_sdk_version(::uint32_t value);
  private:
  ::uint32_t _internal_sdk_version() const;
  void _internal_set_sdk_version(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Configuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
    ::uint32_t mcc_;
    ::uint32_t mnc_;
    int layout_direction_;
    ::uint32_t screen_width_;
    ::uint32_t screen_height_;
    ::uint32_t screen_width_dp_;
    ::uint32_t screen_height_dp_;
    ::uint32_t smallest_screen_width_dp_;
    int screen_layout_size_;
    int screen_layout_long_;
    int screen_round_;
    int wide_color_gamut_;
    int hdr_;
    int orientation_;
    int ui_mode_type_;
    int ui_mode_night_;
    ::uint32_t density_;
    int touchscreen_;
    int keys_hidden_;
    int keyboard_;
    int nav_hidden_;
    int navigation_;
    ::uint32_t sdk_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Configuration_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Configuration

// uint32 mcc = 1;
inline void Configuration::clear_mcc() {
  _impl_.mcc_ = 0u;
}
inline ::uint32_t Configuration::_internal_mcc() const {
  return _impl_.mcc_;
}
inline ::uint32_t Configuration::mcc() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mcc)
  return _internal_mcc();
}
inline void Configuration::_internal_set_mcc(::uint32_t value) {
  
  _impl_.mcc_ = value;
}
inline void Configuration::set_mcc(::uint32_t value) {
  _internal_set_mcc(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mcc)
}

// uint32 mnc = 2;
inline void Configuration::clear_mnc() {
  _impl_.mnc_ = 0u;
}
inline ::uint32_t Configuration::_internal_mnc() const {
  return _impl_.mnc_;
}
inline ::uint32_t Configuration::mnc() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mnc)
  return _internal_mnc();
}
inline void Configuration::_internal_set_mnc(::uint32_t value) {
  
  _impl_.mnc_ = value;
}
inline void Configuration::set_mnc(::uint32_t value) {
  _internal_set_mnc(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mnc)
}

// string locale = 3;
inline void Configuration::clear_locale() {
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& Configuration::locale() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Configuration::set_locale(ArgT0&& arg0, ArgT... args) {
 
 _impl_.locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.locale)
}
inline std::string* Configuration::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.locale)
  return _s;
}
inline const std::string& Configuration::_internal_locale() const {
  return _impl_.locale_.Get();
}
inline void Configuration::_internal_set_locale(const std::string& value) {
  
  _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* Configuration::_internal_mutable_locale() {
  
  return _impl_.locale_.Mutable(GetArenaForAllocation());
}
inline std::string* Configuration::release_locale() {
  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.locale)
  return _impl_.locale_.Release();
}
inline void Configuration::set_allocated_locale(std::string* locale) {
  _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.locale_.IsDefault()) {
    _impl_.locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.locale)
}

// .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
inline void Configuration::clear_layout_direction() {
  _impl_.layout_direction_ = 0;
}
inline ::aapt::pb::Configuration_LayoutDirection Configuration::_internal_layout_direction() const {
  return static_cast< ::aapt::pb::Configuration_LayoutDirection >(_impl_.layout_direction_);
}
inline ::aapt::pb::Configuration_LayoutDirection Configuration::layout_direction() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.layout_direction)
  return _internal_layout_direction();
}
inline void Configuration::_internal_set_layout_direction(::aapt::pb::Configuration_LayoutDirection value) {
  
  _impl_.layout_direction_ = value;
}
inline void Configuration::set_layout_direction(::aapt::pb::Configuration_LayoutDirection value) {
  _internal_set_layout_direction(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.layout_direction)
}

// uint32 screen_width = 5;
inline void Configuration::clear_screen_width() {
  _impl_.screen_width_ = 0u;
}
inline ::uint32_t Configuration::_internal_screen_width() const {
  return _impl_.screen_width_;
}
inline ::uint32_t Configuration::screen_width() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width)
  return _internal_screen_width();
}
inline void Configuration::_internal_set_screen_width(::uint32_t value) {
  
  _impl_.screen_width_ = value;
}
inline void Configuration::set_screen_width(::uint32_t value) {
  _internal_set_screen_width(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width)
}

// uint32 screen_height = 6;
inline void Configuration::clear_screen_height() {
  _impl_.screen_height_ = 0u;
}
inline ::uint32_t Configuration::_internal_screen_height() const {
  return _impl_.screen_height_;
}
inline ::uint32_t Configuration::screen_height() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height)
  return _internal_screen_height();
}
inline void Configuration::_internal_set_screen_height(::uint32_t value) {
  
  _impl_.screen_height_ = value;
}
inline void Configuration::set_screen_height(::uint32_t value) {
  _internal_set_screen_height(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height)
}

// uint32 screen_width_dp = 7;
inline void Configuration::clear_screen_width_dp() {
  _impl_.screen_width_dp_ = 0u;
}
inline ::uint32_t Configuration::_internal_screen_width_dp() const {
  return _impl_.screen_width_dp_;
}
inline ::uint32_t Configuration::screen_width_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width_dp)
  return _internal_screen_width_dp();
}
inline void Configuration::_internal_set_screen_width_dp(::uint32_t value) {
  
  _impl_.screen_width_dp_ = value;
}
inline void Configuration::set_screen_width_dp(::uint32_t value) {
  _internal_set_screen_width_dp(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width_dp)
}

// uint32 screen_height_dp = 8;
inline void Configuration::clear_screen_height_dp() {
  _impl_.screen_height_dp_ = 0u;
}
inline ::uint32_t Configuration::_internal_screen_height_dp() const {
  return _impl_.screen_height_dp_;
}
inline ::uint32_t Configuration::screen_height_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height_dp)
  return _internal_screen_height_dp();
}
inline void Configuration::_internal_set_screen_height_dp(::uint32_t value) {
  
  _impl_.screen_height_dp_ = value;
}
inline void Configuration::set_screen_height_dp(::uint32_t value) {
  _internal_set_screen_height_dp(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height_dp)
}

// uint32 smallest_screen_width_dp = 9;
inline void Configuration::clear_smallest_screen_width_dp() {
  _impl_.smallest_screen_width_dp_ = 0u;
}
inline ::uint32_t Configuration::_internal_smallest_screen_width_dp() const {
  return _impl_.smallest_screen_width_dp_;
}
inline ::uint32_t Configuration::smallest_screen_width_dp() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.smallest_screen_width_dp)
  return _internal_smallest_screen_width_dp();
}
inline void Configuration::_internal_set_smallest_screen_width_dp(::uint32_t value) {
  
  _impl_.smallest_screen_width_dp_ = value;
}
inline void Configuration::set_smallest_screen_width_dp(::uint32_t value) {
  _internal_set_smallest_screen_width_dp(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.smallest_screen_width_dp)
}

// .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
inline void Configuration::clear_screen_layout_size() {
  _impl_.screen_layout_size_ = 0;
}
inline ::aapt::pb::Configuration_ScreenLayoutSize Configuration::_internal_screen_layout_size() const {
  return static_cast< ::aapt::pb::Configuration_ScreenLayoutSize >(_impl_.screen_layout_size_);
}
inline ::aapt::pb::Configuration_ScreenLayoutSize Configuration::screen_layout_size() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_size)
  return _internal_screen_layout_size();
}
inline void Configuration::_internal_set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value) {
  
  _impl_.screen_layout_size_ = value;
}
inline void Configuration::set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value) {
  _internal_set_screen_layout_size(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_size)
}

// .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
inline void Configuration::clear_screen_layout_long() {
  _impl_.screen_layout_long_ = 0;
}
inline ::aapt::pb::Configuration_ScreenLayoutLong Configuration::_internal_screen_layout_long() const {
  return static_cast< ::aapt::pb::Configuration_ScreenLayoutLong >(_impl_.screen_layout_long_);
}
inline ::aapt::pb::Configuration_ScreenLayoutLong Configuration::screen_layout_long() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_long)
  return _internal_screen_layout_long();
}
inline void Configuration::_internal_set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value) {
  
  _impl_.screen_layout_long_ = value;
}
inline void Configuration::set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value) {
  _internal_set_screen_layout_long(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_long)
}

// .aapt.pb.Configuration.ScreenRound screen_round = 12;
inline void Configuration::clear_screen_round() {
  _impl_.screen_round_ = 0;
}
inline ::aapt::pb::Configuration_ScreenRound Configuration::_internal_screen_round() const {
  return static_cast< ::aapt::pb::Configuration_ScreenRound >(_impl_.screen_round_);
}
inline ::aapt::pb::Configuration_ScreenRound Configuration::screen_round() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_round)
  return _internal_screen_round();
}
inline void Configuration::_internal_set_screen_round(::aapt::pb::Configuration_ScreenRound value) {
  
  _impl_.screen_round_ = value;
}
inline void Configuration::set_screen_round(::aapt::pb::Configuration_ScreenRound value) {
  _internal_set_screen_round(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_round)
}

// .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
inline void Configuration::clear_wide_color_gamut() {
  _impl_.wide_color_gamut_ = 0;
}
inline ::aapt::pb::Configuration_WideColorGamut Configuration::_internal_wide_color_gamut() const {
  return static_cast< ::aapt::pb::Configuration_WideColorGamut >(_impl_.wide_color_gamut_);
}
inline ::aapt::pb::Configuration_WideColorGamut Configuration::wide_color_gamut() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.wide_color_gamut)
  return _internal_wide_color_gamut();
}
inline void Configuration::_internal_set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value) {
  
  _impl_.wide_color_gamut_ = value;
}
inline void Configuration::set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value) {
  _internal_set_wide_color_gamut(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.wide_color_gamut)
}

// .aapt.pb.Configuration.Hdr hdr = 14;
inline void Configuration::clear_hdr() {
  _impl_.hdr_ = 0;
}
inline ::aapt::pb::Configuration_Hdr Configuration::_internal_hdr() const {
  return static_cast< ::aapt::pb::Configuration_Hdr >(_impl_.hdr_);
}
inline ::aapt::pb::Configuration_Hdr Configuration::hdr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.hdr)
  return _internal_hdr();
}
inline void Configuration::_internal_set_hdr(::aapt::pb::Configuration_Hdr value) {
  
  _impl_.hdr_ = value;
}
inline void Configuration::set_hdr(::aapt::pb::Configuration_Hdr value) {
  _internal_set_hdr(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.hdr)
}

// .aapt.pb.Configuration.Orientation orientation = 15;
inline void Configuration::clear_orientation() {
  _impl_.orientation_ = 0;
}
inline ::aapt::pb::Configuration_Orientation Configuration::_internal_orientation() const {
  return static_cast< ::aapt::pb::Configuration_Orientation >(_impl_.orientation_);
}
inline ::aapt::pb::Configuration_Orientation Configuration::orientation() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.orientation)
  return _internal_orientation();
}
inline void Configuration::_internal_set_orientation(::aapt::pb::Configuration_Orientation value) {
  
  _impl_.orientation_ = value;
}
inline void Configuration::set_orientation(::aapt::pb::Configuration_Orientation value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.orientation)
}

// .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
inline void Configuration::clear_ui_mode_type() {
  _impl_.ui_mode_type_ = 0;
}
inline ::aapt::pb::Configuration_UiModeType Configuration::_internal_ui_mode_type() const {
  return static_cast< ::aapt::pb::Configuration_UiModeType >(_impl_.ui_mode_type_);
}
inline ::aapt::pb::Configuration_UiModeType Configuration::ui_mode_type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_type)
  return _internal_ui_mode_type();
}
inline void Configuration::_internal_set_ui_mode_type(::aapt::pb::Configuration_UiModeType value) {
  
  _impl_.ui_mode_type_ = value;
}
inline void Configuration::set_ui_mode_type(::aapt::pb::Configuration_UiModeType value) {
  _internal_set_ui_mode_type(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_type)
}

// .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
inline void Configuration::clear_ui_mode_night() {
  _impl_.ui_mode_night_ = 0;
}
inline ::aapt::pb::Configuration_UiModeNight Configuration::_internal_ui_mode_night() const {
  return static_cast< ::aapt::pb::Configuration_UiModeNight >(_impl_.ui_mode_night_);
}
inline ::aapt::pb::Configuration_UiModeNight Configuration::ui_mode_night() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_night)
  return _internal_ui_mode_night();
}
inline void Configuration::_internal_set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value) {
  
  _impl_.ui_mode_night_ = value;
}
inline void Configuration::set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value) {
  _internal_set_ui_mode_night(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_night)
}

// uint32 density = 18;
inline void Configuration::clear_density() {
  _impl_.density_ = 0u;
}
inline ::uint32_t Configuration::_internal_density() const {
  return _impl_.density_;
}
inline ::uint32_t Configuration::density() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.density)
  return _internal_density();
}
inline void Configuration::_internal_set_density(::uint32_t value) {
  
  _impl_.density_ = value;
}
inline void Configuration::set_density(::uint32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.density)
}

// .aapt.pb.Configuration.Touchscreen touchscreen = 19;
inline void Configuration::clear_touchscreen() {
  _impl_.touchscreen_ = 0;
}
inline ::aapt::pb::Configuration_Touchscreen Configuration::_internal_touchscreen() const {
  return static_cast< ::aapt::pb::Configuration_Touchscreen >(_impl_.touchscreen_);
}
inline ::aapt::pb::Configuration_Touchscreen Configuration::touchscreen() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.touchscreen)
  return _internal_touchscreen();
}
inline void Configuration::_internal_set_touchscreen(::aapt::pb::Configuration_Touchscreen value) {
  
  _impl_.touchscreen_ = value;
}
inline void Configuration::set_touchscreen(::aapt::pb::Configuration_Touchscreen value) {
  _internal_set_touchscreen(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.touchscreen)
}

// .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
inline void Configuration::clear_keys_hidden() {
  _impl_.keys_hidden_ = 0;
}
inline ::aapt::pb::Configuration_KeysHidden Configuration::_internal_keys_hidden() const {
  return static_cast< ::aapt::pb::Configuration_KeysHidden >(_impl_.keys_hidden_);
}
inline ::aapt::pb::Configuration_KeysHidden Configuration::keys_hidden() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keys_hidden)
  return _internal_keys_hidden();
}
inline void Configuration::_internal_set_keys_hidden(::aapt::pb::Configuration_KeysHidden value) {
  
  _impl_.keys_hidden_ = value;
}
inline void Configuration::set_keys_hidden(::aapt::pb::Configuration_KeysHidden value) {
  _internal_set_keys_hidden(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keys_hidden)
}

// .aapt.pb.Configuration.Keyboard keyboard = 21;
inline void Configuration::clear_keyboard() {
  _impl_.keyboard_ = 0;
}
inline ::aapt::pb::Configuration_Keyboard Configuration::_internal_keyboard() const {
  return static_cast< ::aapt::pb::Configuration_Keyboard >(_impl_.keyboard_);
}
inline ::aapt::pb::Configuration_Keyboard Configuration::keyboard() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keyboard)
  return _internal_keyboard();
}
inline void Configuration::_internal_set_keyboard(::aapt::pb::Configuration_Keyboard value) {
  
  _impl_.keyboard_ = value;
}
inline void Configuration::set_keyboard(::aapt::pb::Configuration_Keyboard value) {
  _internal_set_keyboard(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keyboard)
}

// .aapt.pb.Configuration.NavHidden nav_hidden = 22;
inline void Configuration::clear_nav_hidden() {
  _impl_.nav_hidden_ = 0;
}
inline ::aapt::pb::Configuration_NavHidden Configuration::_internal_nav_hidden() const {
  return static_cast< ::aapt::pb::Configuration_NavHidden >(_impl_.nav_hidden_);
}
inline ::aapt::pb::Configuration_NavHidden Configuration::nav_hidden() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.nav_hidden)
  return _internal_nav_hidden();
}
inline void Configuration::_internal_set_nav_hidden(::aapt::pb::Configuration_NavHidden value) {
  
  _impl_.nav_hidden_ = value;
}
inline void Configuration::set_nav_hidden(::aapt::pb::Configuration_NavHidden value) {
  _internal_set_nav_hidden(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.nav_hidden)
}

// .aapt.pb.Configuration.Navigation navigation = 23;
inline void Configuration::clear_navigation() {
  _impl_.navigation_ = 0;
}
inline ::aapt::pb::Configuration_Navigation Configuration::_internal_navigation() const {
  return static_cast< ::aapt::pb::Configuration_Navigation >(_impl_.navigation_);
}
inline ::aapt::pb::Configuration_Navigation Configuration::navigation() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.navigation)
  return _internal_navigation();
}
inline void Configuration::_internal_set_navigation(::aapt::pb::Configuration_Navigation value) {
  
  _impl_.navigation_ = value;
}
inline void Configuration::set_navigation(::aapt::pb::Configuration_Navigation value) {
  _internal_set_navigation(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.navigation)
}

// uint32 sdk_version = 24;
inline void Configuration::clear_sdk_version() {
  _impl_.sdk_version_ = 0u;
}
inline ::uint32_t Configuration::_internal_sdk_version() const {
  return _impl_.sdk_version_;
}
inline ::uint32_t Configuration::sdk_version() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.sdk_version)
  return _internal_sdk_version();
}
inline void Configuration::_internal_set_sdk_version(::uint32_t value) {
  
  _impl_.sdk_version_ = value;
}
inline void Configuration::set_sdk_version(::uint32_t value) {
  _internal_set_sdk_version(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.sdk_version)
}

// string product = 25;
inline void Configuration::clear_product() {
  _impl_.product_.ClearToEmpty();
}
inline const std::string& Configuration::product() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Configuration::set_product(ArgT0&& arg0, ArgT... args) {
 
 _impl_.product_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.product)
}
inline std::string* Configuration::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.product)
  return _s;
}
inline const std::string& Configuration::_internal_product() const {
  return _impl_.product_.Get();
}
inline void Configuration::_internal_set_product(const std::string& value) {
  
  _impl_.product_.Set(value, GetArenaForAllocation());
}
inline std::string* Configuration::_internal_mutable_product() {
  
  return _impl_.product_.Mutable(GetArenaForAllocation());
}
inline std::string* Configuration::release_product() {
  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.product)
  return _impl_.product_.Release();
}
inline void Configuration::set_allocated_product(std::string* product) {
  _impl_.product_.SetAllocated(product, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_.IsDefault()) {
    _impl_.product_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.product)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::aapt::pb::Configuration_LayoutDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_LayoutDirection>() {
  return ::aapt::pb::Configuration_LayoutDirection_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutSize> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutSize>() {
  return ::aapt::pb::Configuration_ScreenLayoutSize_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutLong> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutLong>() {
  return ::aapt::pb::Configuration_ScreenLayoutLong_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenRound> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenRound>() {
  return ::aapt::pb::Configuration_ScreenRound_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_WideColorGamut> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_WideColorGamut>() {
  return ::aapt::pb::Configuration_WideColorGamut_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Hdr> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Hdr>() {
  return ::aapt::pb::Configuration_Hdr_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Orientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Orientation>() {
  return ::aapt::pb::Configuration_Orientation_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeType>() {
  return ::aapt::pb::Configuration_UiModeType_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeNight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeNight>() {
  return ::aapt::pb::Configuration_UiModeNight_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Touchscreen> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Touchscreen>() {
  return ::aapt::pb::Configuration_Touchscreen_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_KeysHidden> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_KeysHidden>() {
  return ::aapt::pb::Configuration_KeysHidden_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Keyboard> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Keyboard>() {
  return ::aapt::pb::Configuration_Keyboard_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_NavHidden> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_NavHidden>() {
  return ::aapt::pb::Configuration_NavHidden_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Configuration_Navigation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Navigation>() {
  return ::aapt::pb::Configuration_Navigation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto
