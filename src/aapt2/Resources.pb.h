// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Resources.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto

#include <cstdint>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Configuration.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Resources_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Resources_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Resources_2eproto;
namespace aapt {
namespace pb {
class AllowNew;
struct AllowNewDefaultTypeInternal;
extern AllowNewDefaultTypeInternal _AllowNew_default_instance_;
class Array;
struct ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class Array_Element;
struct Array_ElementDefaultTypeInternal;
extern Array_ElementDefaultTypeInternal _Array_Element_default_instance_;
class Attribute;
struct AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class Attribute_Symbol;
struct Attribute_SymbolDefaultTypeInternal;
extern Attribute_SymbolDefaultTypeInternal _Attribute_Symbol_default_instance_;
class Boolean;
struct BooleanDefaultTypeInternal;
extern BooleanDefaultTypeInternal _Boolean_default_instance_;
class CompoundValue;
struct CompoundValueDefaultTypeInternal;
extern CompoundValueDefaultTypeInternal _CompoundValue_default_instance_;
class ConfigValue;
struct ConfigValueDefaultTypeInternal;
extern ConfigValueDefaultTypeInternal _ConfigValue_default_instance_;
class Entry;
struct EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class EntryId;
struct EntryIdDefaultTypeInternal;
extern EntryIdDefaultTypeInternal _EntryId_default_instance_;
class FileReference;
struct FileReferenceDefaultTypeInternal;
extern FileReferenceDefaultTypeInternal _FileReference_default_instance_;
class Id;
struct IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class Overlayable;
struct OverlayableDefaultTypeInternal;
extern OverlayableDefaultTypeInternal _Overlayable_default_instance_;
class OverlayableItem;
struct OverlayableItemDefaultTypeInternal;
extern OverlayableItemDefaultTypeInternal _OverlayableItem_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class PackageId;
struct PackageIdDefaultTypeInternal;
extern PackageIdDefaultTypeInternal _PackageId_default_instance_;
class Plural;
struct PluralDefaultTypeInternal;
extern PluralDefaultTypeInternal _Plural_default_instance_;
class Plural_Entry;
struct Plural_EntryDefaultTypeInternal;
extern Plural_EntryDefaultTypeInternal _Plural_Entry_default_instance_;
class Primitive;
struct PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class Primitive_EmptyType;
struct Primitive_EmptyTypeDefaultTypeInternal;
extern Primitive_EmptyTypeDefaultTypeInternal _Primitive_EmptyType_default_instance_;
class Primitive_NullType;
struct Primitive_NullTypeDefaultTypeInternal;
extern Primitive_NullTypeDefaultTypeInternal _Primitive_NullType_default_instance_;
class RawString;
struct RawStringDefaultTypeInternal;
extern RawStringDefaultTypeInternal _RawString_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class ResourceTable;
struct ResourceTableDefaultTypeInternal;
extern ResourceTableDefaultTypeInternal _ResourceTable_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class SourcePosition;
struct SourcePositionDefaultTypeInternal;
extern SourcePositionDefaultTypeInternal _SourcePosition_default_instance_;
class String;
struct StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class StringPool;
struct StringPoolDefaultTypeInternal;
extern StringPoolDefaultTypeInternal _StringPool_default_instance_;
class Style;
struct StyleDefaultTypeInternal;
extern StyleDefaultTypeInternal _Style_default_instance_;
class Style_Entry;
struct Style_EntryDefaultTypeInternal;
extern Style_EntryDefaultTypeInternal _Style_Entry_default_instance_;
class Styleable;
struct StyleableDefaultTypeInternal;
extern StyleableDefaultTypeInternal _Styleable_default_instance_;
class Styleable_Entry;
struct Styleable_EntryDefaultTypeInternal;
extern Styleable_EntryDefaultTypeInternal _Styleable_Entry_default_instance_;
class StyledString;
struct StyledStringDefaultTypeInternal;
extern StyledStringDefaultTypeInternal _StyledString_default_instance_;
class StyledString_Span;
struct StyledString_SpanDefaultTypeInternal;
extern StyledString_SpanDefaultTypeInternal _StyledString_Span_default_instance_;
class ToolFingerprint;
struct ToolFingerprintDefaultTypeInternal;
extern ToolFingerprintDefaultTypeInternal _ToolFingerprint_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class TypeId;
struct TypeIdDefaultTypeInternal;
extern TypeIdDefaultTypeInternal _TypeId_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Visibility;
struct VisibilityDefaultTypeInternal;
extern VisibilityDefaultTypeInternal _Visibility_default_instance_;
class XmlAttribute;
struct XmlAttributeDefaultTypeInternal;
extern XmlAttributeDefaultTypeInternal _XmlAttribute_default_instance_;
class XmlElement;
struct XmlElementDefaultTypeInternal;
extern XmlElementDefaultTypeInternal _XmlElement_default_instance_;
class XmlNamespace;
struct XmlNamespaceDefaultTypeInternal;
extern XmlNamespaceDefaultTypeInternal _XmlNamespace_default_instance_;
class XmlNode;
struct XmlNodeDefaultTypeInternal;
extern XmlNodeDefaultTypeInternal _XmlNode_default_instance_;
}  // namespace pb
}  // namespace aapt
PROTOBUF_NAMESPACE_OPEN
template<> ::aapt::pb::AllowNew* Arena::CreateMaybeMessage<::aapt::pb::AllowNew>(Arena*);
template<> ::aapt::pb::Array* Arena::CreateMaybeMessage<::aapt::pb::Array>(Arena*);
template<> ::aapt::pb::Array_Element* Arena::CreateMaybeMessage<::aapt::pb::Array_Element>(Arena*);
template<> ::aapt::pb::Attribute* Arena::CreateMaybeMessage<::aapt::pb::Attribute>(Arena*);
template<> ::aapt::pb::Attribute_Symbol* Arena::CreateMaybeMessage<::aapt::pb::Attribute_Symbol>(Arena*);
template<> ::aapt::pb::Boolean* Arena::CreateMaybeMessage<::aapt::pb::Boolean>(Arena*);
template<> ::aapt::pb::CompoundValue* Arena::CreateMaybeMessage<::aapt::pb::CompoundValue>(Arena*);
template<> ::aapt::pb::ConfigValue* Arena::CreateMaybeMessage<::aapt::pb::ConfigValue>(Arena*);
template<> ::aapt::pb::Entry* Arena::CreateMaybeMessage<::aapt::pb::Entry>(Arena*);
template<> ::aapt::pb::EntryId* Arena::CreateMaybeMessage<::aapt::pb::EntryId>(Arena*);
template<> ::aapt::pb::FileReference* Arena::CreateMaybeMessage<::aapt::pb::FileReference>(Arena*);
template<> ::aapt::pb::Id* Arena::CreateMaybeMessage<::aapt::pb::Id>(Arena*);
template<> ::aapt::pb::Item* Arena::CreateMaybeMessage<::aapt::pb::Item>(Arena*);
template<> ::aapt::pb::Overlayable* Arena::CreateMaybeMessage<::aapt::pb::Overlayable>(Arena*);
template<> ::aapt::pb::OverlayableItem* Arena::CreateMaybeMessage<::aapt::pb::OverlayableItem>(Arena*);
template<> ::aapt::pb::Package* Arena::CreateMaybeMessage<::aapt::pb::Package>(Arena*);
template<> ::aapt::pb::PackageId* Arena::CreateMaybeMessage<::aapt::pb::PackageId>(Arena*);
template<> ::aapt::pb::Plural* Arena::CreateMaybeMessage<::aapt::pb::Plural>(Arena*);
template<> ::aapt::pb::Plural_Entry* Arena::CreateMaybeMessage<::aapt::pb::Plural_Entry>(Arena*);
template<> ::aapt::pb::Primitive* Arena::CreateMaybeMessage<::aapt::pb::Primitive>(Arena*);
template<> ::aapt::pb::Primitive_EmptyType* Arena::CreateMaybeMessage<::aapt::pb::Primitive_EmptyType>(Arena*);
template<> ::aapt::pb::Primitive_NullType* Arena::CreateMaybeMessage<::aapt::pb::Primitive_NullType>(Arena*);
template<> ::aapt::pb::RawString* Arena::CreateMaybeMessage<::aapt::pb::RawString>(Arena*);
template<> ::aapt::pb::Reference* Arena::CreateMaybeMessage<::aapt::pb::Reference>(Arena*);
template<> ::aapt::pb::ResourceTable* Arena::CreateMaybeMessage<::aapt::pb::ResourceTable>(Arena*);
template<> ::aapt::pb::Source* Arena::CreateMaybeMessage<::aapt::pb::Source>(Arena*);
template<> ::aapt::pb::SourcePosition* Arena::CreateMaybeMessage<::aapt::pb::SourcePosition>(Arena*);
template<> ::aapt::pb::String* Arena::CreateMaybeMessage<::aapt::pb::String>(Arena*);
template<> ::aapt::pb::StringPool* Arena::CreateMaybeMessage<::aapt::pb::StringPool>(Arena*);
template<> ::aapt::pb::Style* Arena::CreateMaybeMessage<::aapt::pb::Style>(Arena*);
template<> ::aapt::pb::Style_Entry* Arena::CreateMaybeMessage<::aapt::pb::Style_Entry>(Arena*);
template<> ::aapt::pb::Styleable* Arena::CreateMaybeMessage<::aapt::pb::Styleable>(Arena*);
template<> ::aapt::pb::Styleable_Entry* Arena::CreateMaybeMessage<::aapt::pb::Styleable_Entry>(Arena*);
template<> ::aapt::pb::StyledString* Arena::CreateMaybeMessage<::aapt::pb::StyledString>(Arena*);
template<> ::aapt::pb::StyledString_Span* Arena::CreateMaybeMessage<::aapt::pb::StyledString_Span>(Arena*);
template<> ::aapt::pb::ToolFingerprint* Arena::CreateMaybeMessage<::aapt::pb::ToolFingerprint>(Arena*);
template<> ::aapt::pb::Type* Arena::CreateMaybeMessage<::aapt::pb::Type>(Arena*);
template<> ::aapt::pb::TypeId* Arena::CreateMaybeMessage<::aapt::pb::TypeId>(Arena*);
template<> ::aapt::pb::Value* Arena::CreateMaybeMessage<::aapt::pb::Value>(Arena*);
template<> ::aapt::pb::Visibility* Arena::CreateMaybeMessage<::aapt::pb::Visibility>(Arena*);
template<> ::aapt::pb::XmlAttribute* Arena::CreateMaybeMessage<::aapt::pb::XmlAttribute>(Arena*);
template<> ::aapt::pb::XmlElement* Arena::CreateMaybeMessage<::aapt::pb::XmlElement>(Arena*);
template<> ::aapt::pb::XmlNamespace* Arena::CreateMaybeMessage<::aapt::pb::XmlNamespace>(Arena*);
template<> ::aapt::pb::XmlNode* Arena::CreateMaybeMessage<::aapt::pb::XmlNode>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace aapt {
namespace pb {

enum Visibility_Level : int {
  Visibility_Level_UNKNOWN = 0,
  Visibility_Level_PRIVATE = 1,
  Visibility_Level_PUBLIC = 2,
  Visibility_Level_Visibility_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Visibility_Level_Visibility_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Visibility_Level_IsValid(int value);
constexpr Visibility_Level Visibility_Level_Level_MIN = Visibility_Level_UNKNOWN;
constexpr Visibility_Level Visibility_Level_Level_MAX = Visibility_Level_PUBLIC;
constexpr int Visibility_Level_Level_ARRAYSIZE = Visibility_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_Level_descriptor();
template<typename T>
inline const std::string& Visibility_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_Level_descriptor(), enum_t_value);
}
inline bool Visibility_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility_Level>(
    Visibility_Level_descriptor(), name, value);
}
enum OverlayableItem_Policy : int {
  OverlayableItem_Policy_NONE = 0,
  OverlayableItem_Policy_PUBLIC = 1,
  OverlayableItem_Policy_SYSTEM = 2,
  OverlayableItem_Policy_VENDOR = 3,
  OverlayableItem_Policy_PRODUCT = 4,
  OverlayableItem_Policy_SIGNATURE = 5,
  OverlayableItem_Policy_ODM = 6,
  OverlayableItem_Policy_OEM = 7,
  OverlayableItem_Policy_ACTOR = 8,
  OverlayableItem_Policy_CONFIG_SIGNATURE = 9,
  OverlayableItem_Policy_OverlayableItem_Policy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  OverlayableItem_Policy_OverlayableItem_Policy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool OverlayableItem_Policy_IsValid(int value);
constexpr OverlayableItem_Policy OverlayableItem_Policy_Policy_MIN = OverlayableItem_Policy_NONE;
constexpr OverlayableItem_Policy OverlayableItem_Policy_Policy_MAX = OverlayableItem_Policy_CONFIG_SIGNATURE;
constexpr int OverlayableItem_Policy_Policy_ARRAYSIZE = OverlayableItem_Policy_Policy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OverlayableItem_Policy_descriptor();
template<typename T>
inline const std::string& OverlayableItem_Policy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OverlayableItem_Policy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OverlayableItem_Policy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OverlayableItem_Policy_descriptor(), enum_t_value);
}
inline bool OverlayableItem_Policy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OverlayableItem_Policy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OverlayableItem_Policy>(
    OverlayableItem_Policy_descriptor(), name, value);
}
enum Reference_Type : int {
  Reference_Type_REFERENCE = 0,
  Reference_Type_ATTRIBUTE = 1,
  Reference_Type_Reference_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Reference_Type_Reference_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Reference_Type_IsValid(int value);
constexpr Reference_Type Reference_Type_Type_MIN = Reference_Type_REFERENCE;
constexpr Reference_Type Reference_Type_Type_MAX = Reference_Type_ATTRIBUTE;
constexpr int Reference_Type_Type_ARRAYSIZE = Reference_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reference_Type_descriptor();
template<typename T>
inline const std::string& Reference_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Reference_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Reference_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Reference_Type_descriptor(), enum_t_value);
}
inline bool Reference_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Reference_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Reference_Type>(
    Reference_Type_descriptor(), name, value);
}
enum FileReference_Type : int {
  FileReference_Type_UNKNOWN = 0,
  FileReference_Type_PNG = 1,
  FileReference_Type_BINARY_XML = 2,
  FileReference_Type_PROTO_XML = 3,
  FileReference_Type_FileReference_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  FileReference_Type_FileReference_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool FileReference_Type_IsValid(int value);
constexpr FileReference_Type FileReference_Type_Type_MIN = FileReference_Type_UNKNOWN;
constexpr FileReference_Type FileReference_Type_Type_MAX = FileReference_Type_PROTO_XML;
constexpr int FileReference_Type_Type_ARRAYSIZE = FileReference_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileReference_Type_descriptor();
template<typename T>
inline const std::string& FileReference_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileReference_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileReference_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileReference_Type_descriptor(), enum_t_value);
}
inline bool FileReference_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileReference_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileReference_Type>(
    FileReference_Type_descriptor(), name, value);
}
enum Attribute_FormatFlags : int {
  Attribute_FormatFlags_NONE = 0,
  Attribute_FormatFlags_ANY = 65535,
  Attribute_FormatFlags_REFERENCE = 1,
  Attribute_FormatFlags_STRING = 2,
  Attribute_FormatFlags_INTEGER = 4,
  Attribute_FormatFlags_BOOLEAN = 8,
  Attribute_FormatFlags_COLOR = 16,
  Attribute_FormatFlags_FLOAT = 32,
  Attribute_FormatFlags_DIMENSION = 64,
  Attribute_FormatFlags_FRACTION = 128,
  Attribute_FormatFlags_ENUM = 65536,
  Attribute_FormatFlags_FLAGS = 131072,
  Attribute_FormatFlags_Attribute_FormatFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Attribute_FormatFlags_Attribute_FormatFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Attribute_FormatFlags_IsValid(int value);
constexpr Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MIN = Attribute_FormatFlags_NONE;
constexpr Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MAX = Attribute_FormatFlags_FLAGS;
constexpr int Attribute_FormatFlags_FormatFlags_ARRAYSIZE = Attribute_FormatFlags_FormatFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_FormatFlags_descriptor();
template<typename T>
inline const std::string& Attribute_FormatFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Attribute_FormatFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Attribute_FormatFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Attribute_FormatFlags_descriptor(), enum_t_value);
}
inline bool Attribute_FormatFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Attribute_FormatFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Attribute_FormatFlags>(
    Attribute_FormatFlags_descriptor(), name, value);
}
enum Plural_Arity : int {
  Plural_Arity_ZERO = 0,
  Plural_Arity_ONE = 1,
  Plural_Arity_TWO = 2,
  Plural_Arity_FEW = 3,
  Plural_Arity_MANY = 4,
  Plural_Arity_OTHER = 5,
  Plural_Arity_Plural_Arity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
  Plural_Arity_Plural_Arity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
};
bool Plural_Arity_IsValid(int value);
constexpr Plural_Arity Plural_Arity_Arity_MIN = Plural_Arity_ZERO;
constexpr Plural_Arity Plural_Arity_Arity_MAX = Plural_Arity_OTHER;
constexpr int Plural_Arity_Arity_ARRAYSIZE = Plural_Arity_Arity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Plural_Arity_descriptor();
template<typename T>
inline const std::string& Plural_Arity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Plural_Arity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Plural_Arity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Plural_Arity_descriptor(), enum_t_value);
}
inline bool Plural_Arity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Plural_Arity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Plural_Arity>(
    Plural_Arity_descriptor(), name, value);
}
// ===================================================================

class StringPool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StringPool) */ {
 public:
  inline StringPool() : StringPool(nullptr) {}
  ~StringPool() override;
  explicit PROTOBUF_CONSTEXPR StringPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringPool(const StringPool& from);
  StringPool(StringPool&& from) noexcept
    : StringPool() {
    *this = ::std::move(from);
  }

  inline StringPool& operator=(const StringPool& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline StringPool& operator=(StringPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringPool* internal_default_instance() {
    return reinterpret_cast<const StringPool*>(
               &_StringPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StringPool& a, StringPool& b) {
    a.Swap(&b);
  }
  inline void Swap(StringPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringPool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringPool>(arena);
  }
  StringPool* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringPool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringPool& from) {
    StringPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringPool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.StringPool";
  }
  protected:
  explicit StringPool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.StringPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class SourcePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.SourcePosition) */ {
 public:
  inline SourcePosition() : SourcePosition(nullptr) {}
  ~SourcePosition() override;
  explicit PROTOBUF_CONSTEXPR SourcePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourcePosition(const SourcePosition& from);
  SourcePosition(SourcePosition&& from) noexcept
    : SourcePosition() {
    *this = ::std::move(from);
  }

  inline SourcePosition& operator=(const SourcePosition& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline SourcePosition& operator=(SourcePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourcePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourcePosition* internal_default_instance() {
    return reinterpret_cast<const SourcePosition*>(
               &_SourcePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SourcePosition& a, SourcePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(SourcePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourcePosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourcePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourcePosition>(arena);
  }
  SourcePosition* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourcePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourcePosition& from) {
    SourcePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourcePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.SourcePosition";
  }
  protected:
  explicit SourcePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineNumberFieldNumber = 1,
    kColumnNumberFieldNumber = 2,
  };
  // uint32 line_number = 1;
  void clear_line_number();
  ::uint32_t line_number() const;
  void set_line_number(::uint32_t value);
  private:
  ::uint32_t _internal_line_number() const;
  void _internal_set_line_number(::uint32_t value);
  public:

  // uint32 column_number = 2;
  void clear_column_number();
  ::uint32_t column_number() const;
  void set_column_number(::uint32_t value);
  private:
  ::uint32_t _internal_column_number() const;
  void _internal_set_column_number(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.SourcePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t line_number_;
    ::uint32_t column_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Source final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  explicit PROTOBUF_CONSTEXPR Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  Source* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Source& from) {
    Source::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kPathIdxFieldNumber = 1,
  };
  // .aapt.pb.SourcePosition position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::aapt::pb::SourcePosition& position() const;
  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_position();
  ::aapt::pb::SourcePosition* mutable_position();
  void set_allocated_position(::aapt::pb::SourcePosition* position);
  private:
  const ::aapt::pb::SourcePosition& _internal_position() const;
  ::aapt::pb::SourcePosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::aapt::pb::SourcePosition* position);
  ::aapt::pb::SourcePosition* unsafe_arena_release_position();

  // uint32 path_idx = 1;
  void clear_path_idx();
  ::uint32_t path_idx() const;
  void set_path_idx(::uint32_t value);
  private:
  ::uint32_t _internal_path_idx() const;
  void _internal_set_path_idx(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::aapt::pb::SourcePosition* position_;
    ::uint32_t path_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class ToolFingerprint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ToolFingerprint) */ {
 public:
  inline ToolFingerprint() : ToolFingerprint(nullptr) {}
  ~ToolFingerprint() override;
  explicit PROTOBUF_CONSTEXPR ToolFingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolFingerprint(const ToolFingerprint& from);
  ToolFingerprint(ToolFingerprint&& from) noexcept
    : ToolFingerprint() {
    *this = ::std::move(from);
  }

  inline ToolFingerprint& operator=(const ToolFingerprint& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline ToolFingerprint& operator=(ToolFingerprint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolFingerprint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolFingerprint* internal_default_instance() {
    return reinterpret_cast<const ToolFingerprint*>(
               &_ToolFingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ToolFingerprint& a, ToolFingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolFingerprint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolFingerprint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolFingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ToolFingerprint>(arena);
  }
  ToolFingerprint* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolFingerprint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolFingerprint& from) {
    ToolFingerprint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolFingerprint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.ToolFingerprint";
  }
  protected:
  explicit ToolFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string tool = 1;
  void clear_tool();
  const std::string& tool() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool();
  PROTOBUF_NODISCARD std::string* release_tool();
  void set_allocated_tool(std::string* tool);
  private:
  const std::string& _internal_tool() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool(const std::string& value);
  std::string* _internal_mutable_tool();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.ToolFingerprint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class ResourceTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ResourceTable) */ {
 public:
  inline ResourceTable() : ResourceTable(nullptr) {}
  ~ResourceTable() override;
  explicit PROTOBUF_CONSTEXPR ResourceTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceTable(const ResourceTable& from);
  ResourceTable(ResourceTable&& from) noexcept
    : ResourceTable() {
    *this = ::std::move(from);
  }

  inline ResourceTable& operator=(const ResourceTable& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline ResourceTable& operator=(ResourceTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceTable* internal_default_instance() {
    return reinterpret_cast<const ResourceTable*>(
               &_ResourceTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResourceTable& a, ResourceTable& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceTable>(arena);
  }
  ResourceTable* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceTable& from) {
    ResourceTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.ResourceTable";
  }
  protected:
  explicit ResourceTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageFieldNumber = 2,
    kOverlayableFieldNumber = 3,
    kToolFingerprintFieldNumber = 4,
    kSourcePoolFieldNumber = 1,
  };
  // repeated .aapt.pb.Package package = 2;
  int package_size() const;
  private:
  int _internal_package_size() const;
  public:
  void clear_package();
  ::aapt::pb::Package* mutable_package(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >*
      mutable_package();
  private:
  const ::aapt::pb::Package& _internal_package(int index) const;
  ::aapt::pb::Package* _internal_add_package();
  public:
  const ::aapt::pb::Package& package(int index) const;
  ::aapt::pb::Package* add_package();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >&
      package() const;

  // repeated .aapt.pb.Overlayable overlayable = 3;
  int overlayable_size() const;
  private:
  int _internal_overlayable_size() const;
  public:
  void clear_overlayable();
  ::aapt::pb::Overlayable* mutable_overlayable(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >*
      mutable_overlayable();
  private:
  const ::aapt::pb::Overlayable& _internal_overlayable(int index) const;
  ::aapt::pb::Overlayable* _internal_add_overlayable();
  public:
  const ::aapt::pb::Overlayable& overlayable(int index) const;
  ::aapt::pb::Overlayable* add_overlayable();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >&
      overlayable() const;

  // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
  int tool_fingerprint_size() const;
  private:
  int _internal_tool_fingerprint_size() const;
  public:
  void clear_tool_fingerprint();
  ::aapt::pb::ToolFingerprint* mutable_tool_fingerprint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >*
      mutable_tool_fingerprint();
  private:
  const ::aapt::pb::ToolFingerprint& _internal_tool_fingerprint(int index) const;
  ::aapt::pb::ToolFingerprint* _internal_add_tool_fingerprint();
  public:
  const ::aapt::pb::ToolFingerprint& tool_fingerprint(int index) const;
  ::aapt::pb::ToolFingerprint* add_tool_fingerprint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >&
      tool_fingerprint() const;

  // .aapt.pb.StringPool source_pool = 1;
  bool has_source_pool() const;
  private:
  bool _internal_has_source_pool() const;
  public:
  void clear_source_pool();
  const ::aapt::pb::StringPool& source_pool() const;
  PROTOBUF_NODISCARD ::aapt::pb::StringPool* release_source_pool();
  ::aapt::pb::StringPool* mutable_source_pool();
  void set_allocated_source_pool(::aapt::pb::StringPool* source_pool);
  private:
  const ::aapt::pb::StringPool& _internal_source_pool() const;
  ::aapt::pb::StringPool* _internal_mutable_source_pool();
  public:
  void unsafe_arena_set_allocated_source_pool(
      ::aapt::pb::StringPool* source_pool);
  ::aapt::pb::StringPool* unsafe_arena_release_source_pool();

  // @@protoc_insertion_point(class_scope:aapt.pb.ResourceTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package > package_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable > overlayable_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint > tool_fingerprint_;
    ::aapt::pb::StringPool* source_pool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class PackageId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.PackageId) */ {
 public:
  inline PackageId() : PackageId(nullptr) {}
  ~PackageId() override;
  explicit PROTOBUF_CONSTEXPR PackageId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackageId(const PackageId& from);
  PackageId(PackageId&& from) noexcept
    : PackageId() {
    *this = ::std::move(from);
  }

  inline PackageId& operator=(const PackageId& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline PackageId& operator=(PackageId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackageId* internal_default_instance() {
    return reinterpret_cast<const PackageId*>(
               &_PackageId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PackageId& a, PackageId& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PackageId>(arena);
  }
  PackageId* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackageId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PackageId& from) {
    PackageId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.PackageId";
  }
  protected:
  explicit PackageId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  ::uint32_t id() const;
  void set_id(::uint32_t value);
  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.PackageId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  explicit PROTOBUF_CONSTEXPR Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  Package* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Package& from) {
    Package::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kPackageNameFieldNumber = 2,
    kPackageIdFieldNumber = 1,
  };
  // repeated .aapt.pb.Type type = 3;
  int type_size() const;
  private:
  int _internal_type_size() const;
  public:
  void clear_type();
  ::aapt::pb::Type* mutable_type(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >*
      mutable_type();
  private:
  const ::aapt::pb::Type& _internal_type(int index) const;
  ::aapt::pb::Type* _internal_add_type();
  public:
  const ::aapt::pb::Type& type(int index) const;
  ::aapt::pb::Type* add_type();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >&
      type() const;

  // string package_name = 2;
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // .aapt.pb.PackageId package_id = 1;
  bool has_package_id() const;
  private:
  bool _internal_has_package_id() const;
  public:
  void clear_package_id();
  const ::aapt::pb::PackageId& package_id() const;
  PROTOBUF_NODISCARD ::aapt::pb::PackageId* release_package_id();
  ::aapt::pb::PackageId* mutable_package_id();
  void set_allocated_package_id(::aapt::pb::PackageId* package_id);
  private:
  const ::aapt::pb::PackageId& _internal_package_id() const;
  ::aapt::pb::PackageId* _internal_mutable_package_id();
  public:
  void unsafe_arena_set_allocated_package_id(
      ::aapt::pb::PackageId* package_id);
  ::aapt::pb::PackageId* unsafe_arena_release_package_id();

  // @@protoc_insertion_point(class_scope:aapt.pb.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type > type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::aapt::pb::PackageId* package_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class TypeId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.TypeId) */ {
 public:
  inline TypeId() : TypeId(nullptr) {}
  ~TypeId() override;
  explicit PROTOBUF_CONSTEXPR TypeId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeId(const TypeId& from);
  TypeId(TypeId&& from) noexcept
    : TypeId() {
    *this = ::std::move(from);
  }

  inline TypeId& operator=(const TypeId& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline TypeId& operator=(TypeId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeId* internal_default_instance() {
    return reinterpret_cast<const TypeId*>(
               &_TypeId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TypeId& a, TypeId& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TypeId>(arena);
  }
  TypeId* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeId& from) {
    TypeId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.TypeId";
  }
  protected:
  explicit TypeId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  ::uint32_t id() const;
  void set_id(::uint32_t value);
  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.TypeId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit PROTOBUF_CONSTEXPR Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  Type* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Type& from) {
    Type::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 3,
    kNameFieldNumber = 2,
    kTypeIdFieldNumber = 1,
  };
  // repeated .aapt.pb.Entry entry = 3;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::aapt::pb::Entry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >*
      mutable_entry();
  private:
  const ::aapt::pb::Entry& _internal_entry(int index) const;
  ::aapt::pb::Entry* _internal_add_entry();
  public:
  const ::aapt::pb::Entry& entry(int index) const;
  ::aapt::pb::Entry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >&
      entry() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .aapt.pb.TypeId type_id = 1;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  const ::aapt::pb::TypeId& type_id() const;
  PROTOBUF_NODISCARD ::aapt::pb::TypeId* release_type_id();
  ::aapt::pb::TypeId* mutable_type_id();
  void set_allocated_type_id(::aapt::pb::TypeId* type_id);
  private:
  const ::aapt::pb::TypeId& _internal_type_id() const;
  ::aapt::pb::TypeId* _internal_mutable_type_id();
  public:
  void unsafe_arena_set_allocated_type_id(
      ::aapt::pb::TypeId* type_id);
  ::aapt::pb::TypeId* unsafe_arena_release_type_id();

  // @@protoc_insertion_point(class_scope:aapt.pb.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry > entry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::aapt::pb::TypeId* type_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Visibility final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Visibility) */ {
 public:
  inline Visibility() : Visibility(nullptr) {}
  ~Visibility() override;
  explicit PROTOBUF_CONSTEXPR Visibility(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Visibility(const Visibility& from);
  Visibility(Visibility&& from) noexcept
    : Visibility() {
    *this = ::std::move(from);
  }

  inline Visibility& operator=(const Visibility& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Visibility& operator=(Visibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Visibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const Visibility* internal_default_instance() {
    return reinterpret_cast<const Visibility*>(
               &_Visibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Visibility& a, Visibility& b) {
    a.Swap(&b);
  }
  inline void Swap(Visibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Visibility* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Visibility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Visibility>(arena);
  }
  Visibility* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Visibility& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Visibility& from) {
    Visibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visibility* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Visibility";
  }
  protected:
  explicit Visibility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Visibility_Level Level;
  static constexpr Level UNKNOWN =
    Visibility_Level_UNKNOWN;
  static constexpr Level PRIVATE =
    Visibility_Level_PRIVATE;
  static constexpr Level PUBLIC =
    Visibility_Level_PUBLIC;
  static inline bool Level_IsValid(int value) {
    return Visibility_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    Visibility_Level_Level_MIN;
  static constexpr Level Level_MAX =
    Visibility_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    Visibility_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return Visibility_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return Visibility_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return Visibility_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 3,
    kSourceFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string comment = 3;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Visibility.Level level = 1;
  void clear_level();
  ::aapt::pb::Visibility_Level level() const;
  void set_level(::aapt::pb::Visibility_Level value);
  private:
  ::aapt::pb::Visibility_Level _internal_level() const;
  void _internal_set_level(::aapt::pb::Visibility_Level value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Visibility)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class AllowNew final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.AllowNew) */ {
 public:
  inline AllowNew() : AllowNew(nullptr) {}
  ~AllowNew() override;
  explicit PROTOBUF_CONSTEXPR AllowNew(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowNew(const AllowNew& from);
  AllowNew(AllowNew&& from) noexcept
    : AllowNew() {
    *this = ::std::move(from);
  }

  inline AllowNew& operator=(const AllowNew& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline AllowNew& operator=(AllowNew&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowNew& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowNew* internal_default_instance() {
    return reinterpret_cast<const AllowNew*>(
               &_AllowNew_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AllowNew& a, AllowNew& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowNew* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowNew* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowNew* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllowNew>(arena);
  }
  AllowNew* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowNew& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllowNew& from) {
    AllowNew::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowNew* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.AllowNew";
  }
  protected:
  explicit AllowNew(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:aapt.pb.AllowNew)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Overlayable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Overlayable) */ {
 public:
  inline Overlayable() : Overlayable(nullptr) {}
  ~Overlayable() override;
  explicit PROTOBUF_CONSTEXPR Overlayable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Overlayable(const Overlayable& from);
  Overlayable(Overlayable&& from) noexcept
    : Overlayable() {
    *this = ::std::move(from);
  }

  inline Overlayable& operator=(const Overlayable& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Overlayable& operator=(Overlayable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Overlayable& default_instance() {
    return *internal_default_instance();
  }
  static inline const Overlayable* internal_default_instance() {
    return reinterpret_cast<const Overlayable*>(
               &_Overlayable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Overlayable& a, Overlayable& b) {
    a.Swap(&b);
  }
  inline void Swap(Overlayable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Overlayable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Overlayable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Overlayable>(arena);
  }
  Overlayable* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Overlayable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Overlayable& from) {
    Overlayable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Overlayable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Overlayable";
  }
  protected:
  explicit Overlayable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kActorFieldNumber = 3,
    kSourceFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string actor = 3;
  void clear_actor();
  const std::string& actor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor();
  PROTOBUF_NODISCARD std::string* release_actor();
  void set_allocated_actor(std::string* actor);
  private:
  const std::string& _internal_actor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor(const std::string& value);
  std::string* _internal_mutable_actor();
  public:

  // .aapt.pb.Source source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:aapt.pb.Overlayable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_;
    ::aapt::pb::Source* source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class OverlayableItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.OverlayableItem) */ {
 public:
  inline OverlayableItem() : OverlayableItem(nullptr) {}
  ~OverlayableItem() override;
  explicit PROTOBUF_CONSTEXPR OverlayableItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlayableItem(const OverlayableItem& from);
  OverlayableItem(OverlayableItem&& from) noexcept
    : OverlayableItem() {
    *this = ::std::move(from);
  }

  inline OverlayableItem& operator=(const OverlayableItem& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline OverlayableItem& operator=(OverlayableItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverlayableItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverlayableItem* internal_default_instance() {
    return reinterpret_cast<const OverlayableItem*>(
               &_OverlayableItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OverlayableItem& a, OverlayableItem& b) {
    a.Swap(&b);
  }
  inline void Swap(OverlayableItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlayableItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlayableItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OverlayableItem>(arena);
  }
  OverlayableItem* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverlayableItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverlayableItem& from) {
    OverlayableItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlayableItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.OverlayableItem";
  }
  protected:
  explicit OverlayableItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OverlayableItem_Policy Policy;
  static constexpr Policy NONE =
    OverlayableItem_Policy_NONE;
  static constexpr Policy PUBLIC =
    OverlayableItem_Policy_PUBLIC;
  static constexpr Policy SYSTEM =
    OverlayableItem_Policy_SYSTEM;
  static constexpr Policy VENDOR =
    OverlayableItem_Policy_VENDOR;
  static constexpr Policy PRODUCT =
    OverlayableItem_Policy_PRODUCT;
  static constexpr Policy SIGNATURE =
    OverlayableItem_Policy_SIGNATURE;
  static constexpr Policy ODM =
    OverlayableItem_Policy_ODM;
  static constexpr Policy OEM =
    OverlayableItem_Policy_OEM;
  static constexpr Policy ACTOR =
    OverlayableItem_Policy_ACTOR;
  static constexpr Policy CONFIG_SIGNATURE =
    OverlayableItem_Policy_CONFIG_SIGNATURE;
  static inline bool Policy_IsValid(int value) {
    return OverlayableItem_Policy_IsValid(value);
  }
  static constexpr Policy Policy_MIN =
    OverlayableItem_Policy_Policy_MIN;
  static constexpr Policy Policy_MAX =
    OverlayableItem_Policy_Policy_MAX;
  static constexpr int Policy_ARRAYSIZE =
    OverlayableItem_Policy_Policy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Policy_descriptor() {
    return OverlayableItem_Policy_descriptor();
  }
  template<typename T>
  static inline const std::string& Policy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Policy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Policy_Name.");
    return OverlayableItem_Policy_Name(enum_t_value);
  }
  static inline bool Policy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Policy* value) {
    return OverlayableItem_Policy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 3,
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kOverlayableIdxFieldNumber = 4,
  };
  // repeated .aapt.pb.OverlayableItem.Policy policy = 3;
  int policy_size() const;
  private:
  int _internal_policy_size() const;
  public:
  void clear_policy();
  private:
  ::aapt::pb::OverlayableItem_Policy _internal_policy(int index) const;
  void _internal_add_policy(::aapt::pb::OverlayableItem_Policy value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_policy();
  public:
  ::aapt::pb::OverlayableItem_Policy policy(int index) const;
  void set_policy(int index, ::aapt::pb::OverlayableItem_Policy value);
  void add_policy(::aapt::pb::OverlayableItem_Policy value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& policy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_policy();

  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // uint32 overlayable_idx = 4;
  void clear_overlayable_idx();
  ::uint32_t overlayable_idx() const;
  void set_overlayable_idx(::uint32_t value);
  private:
  ::uint32_t _internal_overlayable_idx() const;
  void _internal_set_overlayable_idx(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.OverlayableItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> policy_;
    mutable std::atomic<int> _policy_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::uint32_t overlayable_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class EntryId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.EntryId) */ {
 public:
  inline EntryId() : EntryId(nullptr) {}
  ~EntryId() override;
  explicit PROTOBUF_CONSTEXPR EntryId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntryId(const EntryId& from);
  EntryId(EntryId&& from) noexcept
    : EntryId() {
    *this = ::std::move(from);
  }

  inline EntryId& operator=(const EntryId& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline EntryId& operator=(EntryId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntryId& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntryId* internal_default_instance() {
    return reinterpret_cast<const EntryId*>(
               &_EntryId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EntryId& a, EntryId& b) {
    a.Swap(&b);
  }
  inline void Swap(EntryId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntryId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntryId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntryId>(arena);
  }
  EntryId* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntryId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntryId& from) {
    EntryId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntryId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.EntryId";
  }
  protected:
  explicit EntryId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  ::uint32_t id() const;
  void set_id(::uint32_t value);
  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.EntryId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Entry) */ {
 public:
  inline Entry() : Entry(nullptr) {}
  ~Entry() override;
  explicit PROTOBUF_CONSTEXPR Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  Entry* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entry& from) {
    Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Entry";
  }
  protected:
  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigValueFieldNumber = 6,
    kNameFieldNumber = 2,
    kEntryIdFieldNumber = 1,
    kVisibilityFieldNumber = 3,
    kAllowNewFieldNumber = 4,
    kOverlayableItemFieldNumber = 5,
  };
  // repeated .aapt.pb.ConfigValue config_value = 6;
  int config_value_size() const;
  private:
  int _internal_config_value_size() const;
  public:
  void clear_config_value();
  ::aapt::pb::ConfigValue* mutable_config_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >*
      mutable_config_value();
  private:
  const ::aapt::pb::ConfigValue& _internal_config_value(int index) const;
  ::aapt::pb::ConfigValue* _internal_add_config_value();
  public:
  const ::aapt::pb::ConfigValue& config_value(int index) const;
  ::aapt::pb::ConfigValue* add_config_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >&
      config_value() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .aapt.pb.EntryId entry_id = 1;
  bool has_entry_id() const;
  private:
  bool _internal_has_entry_id() const;
  public:
  void clear_entry_id();
  const ::aapt::pb::EntryId& entry_id() const;
  PROTOBUF_NODISCARD ::aapt::pb::EntryId* release_entry_id();
  ::aapt::pb::EntryId* mutable_entry_id();
  void set_allocated_entry_id(::aapt::pb::EntryId* entry_id);
  private:
  const ::aapt::pb::EntryId& _internal_entry_id() const;
  ::aapt::pb::EntryId* _internal_mutable_entry_id();
  public:
  void unsafe_arena_set_allocated_entry_id(
      ::aapt::pb::EntryId* entry_id);
  ::aapt::pb::EntryId* unsafe_arena_release_entry_id();

  // .aapt.pb.Visibility visibility = 3;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::aapt::pb::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::aapt::pb::Visibility* release_visibility();
  ::aapt::pb::Visibility* mutable_visibility();
  void set_allocated_visibility(::aapt::pb::Visibility* visibility);
  private:
  const ::aapt::pb::Visibility& _internal_visibility() const;
  ::aapt::pb::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::aapt::pb::Visibility* visibility);
  ::aapt::pb::Visibility* unsafe_arena_release_visibility();

  // .aapt.pb.AllowNew allow_new = 4;
  bool has_allow_new() const;
  private:
  bool _internal_has_allow_new() const;
  public:
  void clear_allow_new();
  const ::aapt::pb::AllowNew& allow_new() const;
  PROTOBUF_NODISCARD ::aapt::pb::AllowNew* release_allow_new();
  ::aapt::pb::AllowNew* mutable_allow_new();
  void set_allocated_allow_new(::aapt::pb::AllowNew* allow_new);
  private:
  const ::aapt::pb::AllowNew& _internal_allow_new() const;
  ::aapt::pb::AllowNew* _internal_mutable_allow_new();
  public:
  void unsafe_arena_set_allocated_allow_new(
      ::aapt::pb::AllowNew* allow_new);
  ::aapt::pb::AllowNew* unsafe_arena_release_allow_new();

  // .aapt.pb.OverlayableItem overlayable_item = 5;
  bool has_overlayable_item() const;
  private:
  bool _internal_has_overlayable_item() const;
  public:
  void clear_overlayable_item();
  const ::aapt::pb::OverlayableItem& overlayable_item() const;
  PROTOBUF_NODISCARD ::aapt::pb::OverlayableItem* release_overlayable_item();
  ::aapt::pb::OverlayableItem* mutable_overlayable_item();
  void set_allocated_overlayable_item(::aapt::pb::OverlayableItem* overlayable_item);
  private:
  const ::aapt::pb::OverlayableItem& _internal_overlayable_item() const;
  ::aapt::pb::OverlayableItem* _internal_mutable_overlayable_item();
  public:
  void unsafe_arena_set_allocated_overlayable_item(
      ::aapt::pb::OverlayableItem* overlayable_item);
  ::aapt::pb::OverlayableItem* unsafe_arena_release_overlayable_item();

  // @@protoc_insertion_point(class_scope:aapt.pb.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue > config_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::aapt::pb::EntryId* entry_id_;
    ::aapt::pb::Visibility* visibility_;
    ::aapt::pb::AllowNew* allow_new_;
    ::aapt::pb::OverlayableItem* overlayable_item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class ConfigValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ConfigValue) */ {
 public:
  inline ConfigValue() : ConfigValue(nullptr) {}
  ~ConfigValue() override;
  explicit PROTOBUF_CONSTEXPR ConfigValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigValue(const ConfigValue& from);
  ConfigValue(ConfigValue&& from) noexcept
    : ConfigValue() {
    *this = ::std::move(from);
  }

  inline ConfigValue& operator=(const ConfigValue& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline ConfigValue& operator=(ConfigValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigValue* internal_default_instance() {
    return reinterpret_cast<const ConfigValue*>(
               &_ConfigValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ConfigValue& a, ConfigValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigValue>(arena);
  }
  ConfigValue* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigValue& from) {
    ConfigValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.ConfigValue";
  }
  protected:
  explicit ConfigValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .aapt.pb.Configuration config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::aapt::pb::Configuration& config() const;
  PROTOBUF_NODISCARD ::aapt::pb::Configuration* release_config();
  ::aapt::pb::Configuration* mutable_config();
  void set_allocated_config(::aapt::pb::Configuration* config);
  private:
  const ::aapt::pb::Configuration& _internal_config() const;
  ::aapt::pb::Configuration* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::aapt::pb::Configuration* config);
  ::aapt::pb::Configuration* unsafe_arena_release_config();

  // .aapt.pb.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::aapt::pb::Value& value() const;
  PROTOBUF_NODISCARD ::aapt::pb::Value* release_value();
  ::aapt::pb::Value* mutable_value();
  void set_allocated_value(::aapt::pb::Value* value);
  private:
  const ::aapt::pb::Value& _internal_value() const;
  ::aapt::pb::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::aapt::pb::Value* value);
  ::aapt::pb::Value* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::aapt::pb::Configuration* config_;
    ::aapt::pb::Value* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kItem = 4,
    kCompoundValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  Value* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kWeakFieldNumber = 3,
    kItemFieldNumber = 4,
    kCompoundValueFieldNumber = 5,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // bool weak = 3;
  void clear_weak();
  bool weak() const;
  void set_weak(bool value);
  private:
  bool _internal_weak() const;
  void _internal_set_weak(bool value);
  public:

  // .aapt.pb.Item item = 4;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::aapt::pb::Item& item() const;
  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
  ::aapt::pb::Item* mutable_item();
  void set_allocated_item(::aapt::pb::Item* item);
  private:
  const ::aapt::pb::Item& _internal_item() const;
  ::aapt::pb::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::aapt::pb::Item* item);
  ::aapt::pb::Item* unsafe_arena_release_item();

  // .aapt.pb.CompoundValue compound_value = 5;
  bool has_compound_value() const;
  private:
  bool _internal_has_compound_value() const;
  public:
  void clear_compound_value();
  const ::aapt::pb::CompoundValue& compound_value() const;
  PROTOBUF_NODISCARD ::aapt::pb::CompoundValue* release_compound_value();
  ::aapt::pb::CompoundValue* mutable_compound_value();
  void set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value);
  private:
  const ::aapt::pb::CompoundValue& _internal_compound_value() const;
  ::aapt::pb::CompoundValue* _internal_mutable_compound_value();
  public:
  void unsafe_arena_set_allocated_compound_value(
      ::aapt::pb::CompoundValue* compound_value);
  ::aapt::pb::CompoundValue* unsafe_arena_release_compound_value();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:aapt.pb.Value)
 private:
  class _Internal;
  void set_has_item();
  void set_has_compound_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    bool weak_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aapt::pb::Item* item_;
      ::aapt::pb::CompoundValue* compound_value_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kRef = 1,
    kStr = 2,
    kRawStr = 3,
    kStyledStr = 4,
    kFile = 5,
    kId = 6,
    kPrim = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  Item* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefFieldNumber = 1,
    kStrFieldNumber = 2,
    kRawStrFieldNumber = 3,
    kStyledStrFieldNumber = 4,
    kFileFieldNumber = 5,
    kIdFieldNumber = 6,
    kPrimFieldNumber = 7,
  };
  // .aapt.pb.Reference ref = 1;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::aapt::pb::Reference& ref() const;
  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_ref();
  ::aapt::pb::Reference* mutable_ref();
  void set_allocated_ref(::aapt::pb::Reference* ref);
  private:
  const ::aapt::pb::Reference& _internal_ref() const;
  ::aapt::pb::Reference* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::aapt::pb::Reference* ref);
  ::aapt::pb::Reference* unsafe_arena_release_ref();

  // .aapt.pb.String str = 2;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const ::aapt::pb::String& str() const;
  PROTOBUF_NODISCARD ::aapt::pb::String* release_str();
  ::aapt::pb::String* mutable_str();
  void set_allocated_str(::aapt::pb::String* str);
  private:
  const ::aapt::pb::String& _internal_str() const;
  ::aapt::pb::String* _internal_mutable_str();
  public:
  void unsafe_arena_set_allocated_str(
      ::aapt::pb::String* str);
  ::aapt::pb::String* unsafe_arena_release_str();

  // .aapt.pb.RawString raw_str = 3;
  bool has_raw_str() const;
  private:
  bool _internal_has_raw_str() const;
  public:
  void clear_raw_str();
  const ::aapt::pb::RawString& raw_str() const;
  PROTOBUF_NODISCARD ::aapt::pb::RawString* release_raw_str();
  ::aapt::pb::RawString* mutable_raw_str();
  void set_allocated_raw_str(::aapt::pb::RawString* raw_str);
  private:
  const ::aapt::pb::RawString& _internal_raw_str() const;
  ::aapt::pb::RawString* _internal_mutable_raw_str();
  public:
  void unsafe_arena_set_allocated_raw_str(
      ::aapt::pb::RawString* raw_str);
  ::aapt::pb::RawString* unsafe_arena_release_raw_str();

  // .aapt.pb.StyledString styled_str = 4;
  bool has_styled_str() const;
  private:
  bool _internal_has_styled_str() const;
  public:
  void clear_styled_str();
  const ::aapt::pb::StyledString& styled_str() const;
  PROTOBUF_NODISCARD ::aapt::pb::StyledString* release_styled_str();
  ::aapt::pb::StyledString* mutable_styled_str();
  void set_allocated_styled_str(::aapt::pb::StyledString* styled_str);
  private:
  const ::aapt::pb::StyledString& _internal_styled_str() const;
  ::aapt::pb::StyledString* _internal_mutable_styled_str();
  public:
  void unsafe_arena_set_allocated_styled_str(
      ::aapt::pb::StyledString* styled_str);
  ::aapt::pb::StyledString* unsafe_arena_release_styled_str();

  // .aapt.pb.FileReference file = 5;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::aapt::pb::FileReference& file() const;
  PROTOBUF_NODISCARD ::aapt::pb::FileReference* release_file();
  ::aapt::pb::FileReference* mutable_file();
  void set_allocated_file(::aapt::pb::FileReference* file);
  private:
  const ::aapt::pb::FileReference& _internal_file() const;
  ::aapt::pb::FileReference* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::aapt::pb::FileReference* file);
  ::aapt::pb::FileReference* unsafe_arena_release_file();

  // .aapt.pb.Id id = 6;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::aapt::pb::Id& id() const;
  PROTOBUF_NODISCARD ::aapt::pb::Id* release_id();
  ::aapt::pb::Id* mutable_id();
  void set_allocated_id(::aapt::pb::Id* id);
  private:
  const ::aapt::pb::Id& _internal_id() const;
  ::aapt::pb::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::aapt::pb::Id* id);
  ::aapt::pb::Id* unsafe_arena_release_id();

  // .aapt.pb.Primitive prim = 7;
  bool has_prim() const;
  private:
  bool _internal_has_prim() const;
  public:
  void clear_prim();
  const ::aapt::pb::Primitive& prim() const;
  PROTOBUF_NODISCARD ::aapt::pb::Primitive* release_prim();
  ::aapt::pb::Primitive* mutable_prim();
  void set_allocated_prim(::aapt::pb::Primitive* prim);
  private:
  const ::aapt::pb::Primitive& _internal_prim() const;
  ::aapt::pb::Primitive* _internal_mutable_prim();
  public:
  void unsafe_arena_set_allocated_prim(
      ::aapt::pb::Primitive* prim);
  ::aapt::pb::Primitive* unsafe_arena_release_prim();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:aapt.pb.Item)
 private:
  class _Internal;
  void set_has_ref();
  void set_has_str();
  void set_has_raw_str();
  void set_has_styled_str();
  void set_has_file();
  void set_has_id();
  void set_has_prim();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aapt::pb::Reference* ref_;
      ::aapt::pb::String* str_;
      ::aapt::pb::RawString* raw_str_;
      ::aapt::pb::StyledString* styled_str_;
      ::aapt::pb::FileReference* file_;
      ::aapt::pb::Id* id_;
      ::aapt::pb::Primitive* prim_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class CompoundValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.CompoundValue) */ {
 public:
  inline CompoundValue() : CompoundValue(nullptr) {}
  ~CompoundValue() override;
  explicit PROTOBUF_CONSTEXPR CompoundValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompoundValue(const CompoundValue& from);
  CompoundValue(CompoundValue&& from) noexcept
    : CompoundValue() {
    *this = ::std::move(from);
  }

  inline CompoundValue& operator=(const CompoundValue& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline CompoundValue& operator=(CompoundValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompoundValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAttr = 1,
    kStyle = 2,
    kStyleable = 3,
    kArray = 4,
    kPlural = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const CompoundValue* internal_default_instance() {
    return reinterpret_cast<const CompoundValue*>(
               &_CompoundValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CompoundValue& a, CompoundValue& b) {
    a.Swap(&b);
  }
  inline void Swap(CompoundValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompoundValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompoundValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompoundValue>(arena);
  }
  CompoundValue* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompoundValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompoundValue& from) {
    CompoundValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompoundValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.CompoundValue";
  }
  protected:
  explicit CompoundValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttrFieldNumber = 1,
    kStyleFieldNumber = 2,
    kStyleableFieldNumber = 3,
    kArrayFieldNumber = 4,
    kPluralFieldNumber = 5,
  };
  // .aapt.pb.Attribute attr = 1;
  bool has_attr() const;
  private:
  bool _internal_has_attr() const;
  public:
  void clear_attr();
  const ::aapt::pb::Attribute& attr() const;
  PROTOBUF_NODISCARD ::aapt::pb::Attribute* release_attr();
  ::aapt::pb::Attribute* mutable_attr();
  void set_allocated_attr(::aapt::pb::Attribute* attr);
  private:
  const ::aapt::pb::Attribute& _internal_attr() const;
  ::aapt::pb::Attribute* _internal_mutable_attr();
  public:
  void unsafe_arena_set_allocated_attr(
      ::aapt::pb::Attribute* attr);
  ::aapt::pb::Attribute* unsafe_arena_release_attr();

  // .aapt.pb.Style style = 2;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::aapt::pb::Style& style() const;
  PROTOBUF_NODISCARD ::aapt::pb::Style* release_style();
  ::aapt::pb::Style* mutable_style();
  void set_allocated_style(::aapt::pb::Style* style);
  private:
  const ::aapt::pb::Style& _internal_style() const;
  ::aapt::pb::Style* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::aapt::pb::Style* style);
  ::aapt::pb::Style* unsafe_arena_release_style();

  // .aapt.pb.Styleable styleable = 3;
  bool has_styleable() const;
  private:
  bool _internal_has_styleable() const;
  public:
  void clear_styleable();
  const ::aapt::pb::Styleable& styleable() const;
  PROTOBUF_NODISCARD ::aapt::pb::Styleable* release_styleable();
  ::aapt::pb::Styleable* mutable_styleable();
  void set_allocated_styleable(::aapt::pb::Styleable* styleable);
  private:
  const ::aapt::pb::Styleable& _internal_styleable() const;
  ::aapt::pb::Styleable* _internal_mutable_styleable();
  public:
  void unsafe_arena_set_allocated_styleable(
      ::aapt::pb::Styleable* styleable);
  ::aapt::pb::Styleable* unsafe_arena_release_styleable();

  // .aapt.pb.Array array = 4;
  bool has_array() const;
  private:
  bool _internal_has_array() const;
  public:
  void clear_array();
  const ::aapt::pb::Array& array() const;
  PROTOBUF_NODISCARD ::aapt::pb::Array* release_array();
  ::aapt::pb::Array* mutable_array();
  void set_allocated_array(::aapt::pb::Array* array);
  private:
  const ::aapt::pb::Array& _internal_array() const;
  ::aapt::pb::Array* _internal_mutable_array();
  public:
  void unsafe_arena_set_allocated_array(
      ::aapt::pb::Array* array);
  ::aapt::pb::Array* unsafe_arena_release_array();

  // .aapt.pb.Plural plural = 5;
  bool has_plural() const;
  private:
  bool _internal_has_plural() const;
  public:
  void clear_plural();
  const ::aapt::pb::Plural& plural() const;
  PROTOBUF_NODISCARD ::aapt::pb::Plural* release_plural();
  ::aapt::pb::Plural* mutable_plural();
  void set_allocated_plural(::aapt::pb::Plural* plural);
  private:
  const ::aapt::pb::Plural& _internal_plural() const;
  ::aapt::pb::Plural* _internal_mutable_plural();
  public:
  void unsafe_arena_set_allocated_plural(
      ::aapt::pb::Plural* plural);
  ::aapt::pb::Plural* unsafe_arena_release_plural();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:aapt.pb.CompoundValue)
 private:
  class _Internal;
  void set_has_attr();
  void set_has_style();
  void set_has_styleable();
  void set_has_array();
  void set_has_plural();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aapt::pb::Attribute* attr_;
      ::aapt::pb::Style* style_;
      ::aapt::pb::Styleable* styleable_;
      ::aapt::pb::Array* array_;
      ::aapt::pb::Plural* plural_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Boolean final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Boolean) */ {
 public:
  inline Boolean() : Boolean(nullptr) {}
  ~Boolean() override;
  explicit PROTOBUF_CONSTEXPR Boolean(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Boolean(const Boolean& from);
  Boolean(Boolean&& from) noexcept
    : Boolean() {
    *this = ::std::move(from);
  }

  inline Boolean& operator=(const Boolean& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Boolean& operator=(Boolean&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Boolean& default_instance() {
    return *internal_default_instance();
  }
  static inline const Boolean* internal_default_instance() {
    return reinterpret_cast<const Boolean*>(
               &_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Boolean& a, Boolean& b) {
    a.Swap(&b);
  }
  inline void Swap(Boolean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Boolean* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Boolean* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Boolean>(arena);
  }
  Boolean* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Boolean& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Boolean& from) {
    Boolean::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Boolean* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Boolean";
  }
  protected:
  explicit Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Boolean)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Reference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  explicit PROTOBUF_CONSTEXPR Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reference(const Reference& from);
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  Reference* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reference& from) {
    Reference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Reference";
  }
  protected:
  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Reference_Type Type;
  static constexpr Type REFERENCE =
    Reference_Type_REFERENCE;
  static constexpr Type ATTRIBUTE =
    Reference_Type_ATTRIBUTE;
  static inline bool Type_IsValid(int value) {
    return Reference_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Reference_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Reference_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Reference_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Reference_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Reference_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Reference_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kIsDynamicFieldNumber = 5,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kPrivateFieldNumber = 4,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .aapt.pb.Boolean is_dynamic = 5;
  bool has_is_dynamic() const;
  private:
  bool _internal_has_is_dynamic() const;
  public:
  void clear_is_dynamic();
  const ::aapt::pb::Boolean& is_dynamic() const;
  PROTOBUF_NODISCARD ::aapt::pb::Boolean* release_is_dynamic();
  ::aapt::pb::Boolean* mutable_is_dynamic();
  void set_allocated_is_dynamic(::aapt::pb::Boolean* is_dynamic);
  private:
  const ::aapt::pb::Boolean& _internal_is_dynamic() const;
  ::aapt::pb::Boolean* _internal_mutable_is_dynamic();
  public:
  void unsafe_arena_set_allocated_is_dynamic(
      ::aapt::pb::Boolean* is_dynamic);
  ::aapt::pb::Boolean* unsafe_arena_release_is_dynamic();

  // .aapt.pb.Reference.Type type = 1;
  void clear_type();
  ::aapt::pb::Reference_Type type() const;
  void set_type(::aapt::pb::Reference_Type value);
  private:
  ::aapt::pb::Reference_Type _internal_type() const;
  void _internal_set_type(::aapt::pb::Reference_Type value);
  public:

  // uint32 id = 2;
  void clear_id();
  ::uint32_t id() const;
  void set_id(::uint32_t value);
  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);
  public:

  // bool private = 4;
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Reference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::aapt::pb::Boolean* is_dynamic_;
    int type_;
    ::uint32_t id_;
    bool private__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Id final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Id) */ {
 public:
  inline Id() : Id(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Id(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Id(const Id& from);
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(const Id& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Id& operator=(Id&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Id& default_instance() {
    return *internal_default_instance();
  }
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }
  inline void Swap(Id* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Id* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Id* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Id>(arena);
  }
  Id* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Id& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Id& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Id";
  }
  protected:
  explicit Id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aapt.pb.Id)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class String final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.String) */ {
 public:
  inline String() : String(nullptr) {}
  ~String() override;
  explicit PROTOBUF_CONSTEXPR String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  String(const String& from);
  String(String&& from) noexcept
    : String() {
    *this = ::std::move(from);
  }

  inline String& operator=(const String& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline String& operator=(String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const String& default_instance() {
    return *internal_default_instance();
  }
  static inline const String* internal_default_instance() {
    return reinterpret_cast<const String*>(
               &_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(String& a, String& b) {
    a.Swap(&b);
  }
  inline void Swap(String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<String>(arena);
  }
  String* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const String& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const String& from) {
    String::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(String* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.String";
  }
  protected:
  explicit String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.String)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class RawString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.RawString) */ {
 public:
  inline RawString() : RawString(nullptr) {}
  ~RawString() override;
  explicit PROTOBUF_CONSTEXPR RawString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RawString(const RawString& from);
  RawString(RawString&& from) noexcept
    : RawString() {
    *this = ::std::move(from);
  }

  inline RawString& operator=(const RawString& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline RawString& operator=(RawString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RawString& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawString* internal_default_instance() {
    return reinterpret_cast<const RawString*>(
               &_RawString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RawString& a, RawString& b) {
    a.Swap(&b);
  }
  inline void Swap(RawString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RawString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawString>(arena);
  }
  RawString* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RawString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RawString& from) {
    RawString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.RawString";
  }
  protected:
  explicit RawString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.RawString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class StyledString_Span final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyledString.Span) */ {
 public:
  inline StyledString_Span() : StyledString_Span(nullptr) {}
  ~StyledString_Span() override;
  explicit PROTOBUF_CONSTEXPR StyledString_Span(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyledString_Span(const StyledString_Span& from);
  StyledString_Span(StyledString_Span&& from) noexcept
    : StyledString_Span() {
    *this = ::std::move(from);
  }

  inline StyledString_Span& operator=(const StyledString_Span& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline StyledString_Span& operator=(StyledString_Span&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyledString_Span& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyledString_Span* internal_default_instance() {
    return reinterpret_cast<const StyledString_Span*>(
               &_StyledString_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StyledString_Span& a, StyledString_Span& b) {
    a.Swap(&b);
  }
  inline void Swap(StyledString_Span* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyledString_Span* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyledString_Span* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StyledString_Span>(arena);
  }
  StyledString_Span* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyledString_Span& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyledString_Span& from) {
    StyledString_Span::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyledString_Span* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.StyledString.Span";
  }
  protected:
  explicit StyledString_Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kFirstCharFieldNumber = 2,
    kLastCharFieldNumber = 3,
  };
  // string tag = 1;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // uint32 first_char = 2;
  void clear_first_char();
  ::uint32_t first_char() const;
  void set_first_char(::uint32_t value);
  private:
  ::uint32_t _internal_first_char() const;
  void _internal_set_first_char(::uint32_t value);
  public:

  // uint32 last_char = 3;
  void clear_last_char();
  ::uint32_t last_char() const;
  void set_last_char(::uint32_t value);
  private:
  ::uint32_t _internal_last_char() const;
  void _internal_set_last_char(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString.Span)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::uint32_t first_char_;
    ::uint32_t last_char_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class StyledString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyledString) */ {
 public:
  inline StyledString() : StyledString(nullptr) {}
  ~StyledString() override;
  explicit PROTOBUF_CONSTEXPR StyledString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyledString(const StyledString& from);
  StyledString(StyledString&& from) noexcept
    : StyledString() {
    *this = ::std::move(from);
  }

  inline StyledString& operator=(const StyledString& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline StyledString& operator=(StyledString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyledString& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyledString* internal_default_instance() {
    return reinterpret_cast<const StyledString*>(
               &_StyledString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StyledString& a, StyledString& b) {
    a.Swap(&b);
  }
  inline void Swap(StyledString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyledString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyledString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StyledString>(arena);
  }
  StyledString* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyledString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyledString& from) {
    StyledString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyledString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.StyledString";
  }
  protected:
  explicit StyledString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StyledString_Span Span;

  // accessors -------------------------------------------------------

  enum : int {
    kSpanFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // repeated .aapt.pb.StyledString.Span span = 2;
  int span_size() const;
  private:
  int _internal_span_size() const;
  public:
  void clear_span();
  ::aapt::pb::StyledString_Span* mutable_span(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
      mutable_span();
  private:
  const ::aapt::pb::StyledString_Span& _internal_span(int index) const;
  ::aapt::pb::StyledString_Span* _internal_add_span();
  public:
  const ::aapt::pb::StyledString_Span& span(int index) const;
  ::aapt::pb::StyledString_Span* add_span();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
      span() const;

  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span > span_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class FileReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.FileReference) */ {
 public:
  inline FileReference() : FileReference(nullptr) {}
  ~FileReference() override;
  explicit PROTOBUF_CONSTEXPR FileReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileReference(const FileReference& from);
  FileReference(FileReference&& from) noexcept
    : FileReference() {
    *this = ::std::move(from);
  }

  inline FileReference& operator=(const FileReference& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline FileReference& operator=(FileReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileReference* internal_default_instance() {
    return reinterpret_cast<const FileReference*>(
               &_FileReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FileReference& a, FileReference& b) {
    a.Swap(&b);
  }
  inline void Swap(FileReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileReference>(arena);
  }
  FileReference* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileReference& from) {
    FileReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.FileReference";
  }
  protected:
  explicit FileReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileReference_Type Type;
  static constexpr Type UNKNOWN =
    FileReference_Type_UNKNOWN;
  static constexpr Type PNG =
    FileReference_Type_PNG;
  static constexpr Type BINARY_XML =
    FileReference_Type_BINARY_XML;
  static constexpr Type PROTO_XML =
    FileReference_Type_PROTO_XML;
  static inline bool Type_IsValid(int value) {
    return FileReference_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FileReference_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FileReference_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FileReference_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return FileReference_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FileReference_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return FileReference_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .aapt.pb.FileReference.Type type = 2;
  void clear_type();
  ::aapt::pb::FileReference_Type type() const;
  void set_type(::aapt::pb::FileReference_Type value);
  private:
  ::aapt::pb::FileReference_Type _internal_type() const;
  void _internal_set_type(::aapt::pb::FileReference_Type value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.FileReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Primitive_NullType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive.NullType) */ {
 public:
  inline Primitive_NullType() : Primitive_NullType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Primitive_NullType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Primitive_NullType(const Primitive_NullType& from);
  Primitive_NullType(Primitive_NullType&& from) noexcept
    : Primitive_NullType() {
    *this = ::std::move(from);
  }

  inline Primitive_NullType& operator=(const Primitive_NullType& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Primitive_NullType& operator=(Primitive_NullType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive_NullType& default_instance() {
    return *internal_default_instance();
  }
  static inline const Primitive_NullType* internal_default_instance() {
    return reinterpret_cast<const Primitive_NullType*>(
               &_Primitive_NullType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Primitive_NullType& a, Primitive_NullType& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive_NullType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive_NullType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive_NullType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Primitive_NullType>(arena);
  }
  Primitive_NullType* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Primitive_NullType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Primitive_NullType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Primitive.NullType";
  }
  protected:
  explicit Primitive_NullType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive.NullType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Primitive_EmptyType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive.EmptyType) */ {
 public:
  inline Primitive_EmptyType() : Primitive_EmptyType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Primitive_EmptyType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Primitive_EmptyType(const Primitive_EmptyType& from);
  Primitive_EmptyType(Primitive_EmptyType&& from) noexcept
    : Primitive_EmptyType() {
    *this = ::std::move(from);
  }

  inline Primitive_EmptyType& operator=(const Primitive_EmptyType& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Primitive_EmptyType& operator=(Primitive_EmptyType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive_EmptyType& default_instance() {
    return *internal_default_instance();
  }
  static inline const Primitive_EmptyType* internal_default_instance() {
    return reinterpret_cast<const Primitive_EmptyType*>(
               &_Primitive_EmptyType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Primitive_EmptyType& a, Primitive_EmptyType& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive_EmptyType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive_EmptyType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive_EmptyType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Primitive_EmptyType>(arena);
  }
  Primitive_EmptyType* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Primitive_EmptyType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Primitive_EmptyType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Primitive.EmptyType";
  }
  protected:
  explicit Primitive_EmptyType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive.EmptyType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Primitive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive) */ {
 public:
  inline Primitive() : Primitive(nullptr) {}
  ~Primitive() override;
  explicit PROTOBUF_CONSTEXPR Primitive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Primitive(const Primitive& from);
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(const Primitive& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Primitive& operator=(Primitive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive& default_instance() {
    return *internal_default_instance();
  }
  enum OneofValueCase {
    kNullValue = 1,
    kEmptyValue = 2,
    kFloatValue = 3,
    kDimensionValue = 13,
    kFractionValue = 14,
    kIntDecimalValue = 6,
    kIntHexadecimalValue = 7,
    kBooleanValue = 8,
    kColorArgb8Value = 9,
    kColorRgb8Value = 10,
    kColorArgb4Value = 11,
    kColorRgb4Value = 12,
    kDimensionValueDeprecated = 4,
    kFractionValueDeprecated = 5,
    ONEOF_VALUE_NOT_SET = 0,
  };

  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  Primitive* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Primitive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Primitive& from) {
    Primitive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Primitive";
  }
  protected:
  explicit Primitive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Primitive_NullType NullType;
  typedef Primitive_EmptyType EmptyType;

  // accessors -------------------------------------------------------

  enum : int {
    kNullValueFieldNumber = 1,
    kEmptyValueFieldNumber = 2,
    kFloatValueFieldNumber = 3,
    kDimensionValueFieldNumber = 13,
    kFractionValueFieldNumber = 14,
    kIntDecimalValueFieldNumber = 6,
    kIntHexadecimalValueFieldNumber = 7,
    kBooleanValueFieldNumber = 8,
    kColorArgb8ValueFieldNumber = 9,
    kColorRgb8ValueFieldNumber = 10,
    kColorArgb4ValueFieldNumber = 11,
    kColorRgb4ValueFieldNumber = 12,
    kDimensionValueDeprecatedFieldNumber = 4,
    kFractionValueDeprecatedFieldNumber = 5,
  };
  // .aapt.pb.Primitive.NullType null_value = 1;
  bool has_null_value() const;
  private:
  bool _internal_has_null_value() const;
  public:
  void clear_null_value();
  const ::aapt::pb::Primitive_NullType& null_value() const;
  PROTOBUF_NODISCARD ::aapt::pb::Primitive_NullType* release_null_value();
  ::aapt::pb::Primitive_NullType* mutable_null_value();
  void set_allocated_null_value(::aapt::pb::Primitive_NullType* null_value);
  private:
  const ::aapt::pb::Primitive_NullType& _internal_null_value() const;
  ::aapt::pb::Primitive_NullType* _internal_mutable_null_value();
  public:
  void unsafe_arena_set_allocated_null_value(
      ::aapt::pb::Primitive_NullType* null_value);
  ::aapt::pb::Primitive_NullType* unsafe_arena_release_null_value();

  // .aapt.pb.Primitive.EmptyType empty_value = 2;
  bool has_empty_value() const;
  private:
  bool _internal_has_empty_value() const;
  public:
  void clear_empty_value();
  const ::aapt::pb::Primitive_EmptyType& empty_value() const;
  PROTOBUF_NODISCARD ::aapt::pb::Primitive_EmptyType* release_empty_value();
  ::aapt::pb::Primitive_EmptyType* mutable_empty_value();
  void set_allocated_empty_value(::aapt::pb::Primitive_EmptyType* empty_value);
  private:
  const ::aapt::pb::Primitive_EmptyType& _internal_empty_value() const;
  ::aapt::pb::Primitive_EmptyType* _internal_mutable_empty_value();
  public:
  void unsafe_arena_set_allocated_empty_value(
      ::aapt::pb::Primitive_EmptyType* empty_value);
  ::aapt::pb::Primitive_EmptyType* unsafe_arena_release_empty_value();

  // float float_value = 3;
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);
  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);
  public:

  // uint32 dimension_value = 13;
  bool has_dimension_value() const;
  private:
  bool _internal_has_dimension_value() const;
  public:
  void clear_dimension_value();
  ::uint32_t dimension_value() const;
  void set_dimension_value(::uint32_t value);
  private:
  ::uint32_t _internal_dimension_value() const;
  void _internal_set_dimension_value(::uint32_t value);
  public:

  // uint32 fraction_value = 14;
  bool has_fraction_value() const;
  private:
  bool _internal_has_fraction_value() const;
  public:
  void clear_fraction_value();
  ::uint32_t fraction_value() const;
  void set_fraction_value(::uint32_t value);
  private:
  ::uint32_t _internal_fraction_value() const;
  void _internal_set_fraction_value(::uint32_t value);
  public:

  // int32 int_decimal_value = 6;
  bool has_int_decimal_value() const;
  private:
  bool _internal_has_int_decimal_value() const;
  public:
  void clear_int_decimal_value();
  ::int32_t int_decimal_value() const;
  void set_int_decimal_value(::int32_t value);
  private:
  ::int32_t _internal_int_decimal_value() const;
  void _internal_set_int_decimal_value(::int32_t value);
  public:

  // uint32 int_hexadecimal_value = 7;
  bool has_int_hexadecimal_value() const;
  private:
  bool _internal_has_int_hexadecimal_value() const;
  public:
  void clear_int_hexadecimal_value();
  ::uint32_t int_hexadecimal_value() const;
  void set_int_hexadecimal_value(::uint32_t value);
  private:
  ::uint32_t _internal_int_hexadecimal_value() const;
  void _internal_set_int_hexadecimal_value(::uint32_t value);
  public:

  // bool boolean_value = 8;
  bool has_boolean_value() const;
  private:
  bool _internal_has_boolean_value() const;
  public:
  void clear_boolean_value();
  bool boolean_value() const;
  void set_boolean_value(bool value);
  private:
  bool _internal_boolean_value() const;
  void _internal_set_boolean_value(bool value);
  public:

  // uint32 color_argb8_value = 9;
  bool has_color_argb8_value() const;
  private:
  bool _internal_has_color_argb8_value() const;
  public:
  void clear_color_argb8_value();
  ::uint32_t color_argb8_value() const;
  void set_color_argb8_value(::uint32_t value);
  private:
  ::uint32_t _internal_color_argb8_value() const;
  void _internal_set_color_argb8_value(::uint32_t value);
  public:

  // uint32 color_rgb8_value = 10;
  bool has_color_rgb8_value() const;
  private:
  bool _internal_has_color_rgb8_value() const;
  public:
  void clear_color_rgb8_value();
  ::uint32_t color_rgb8_value() const;
  void set_color_rgb8_value(::uint32_t value);
  private:
  ::uint32_t _internal_color_rgb8_value() const;
  void _internal_set_color_rgb8_value(::uint32_t value);
  public:

  // uint32 color_argb4_value = 11;
  bool has_color_argb4_value() const;
  private:
  bool _internal_has_color_argb4_value() const;
  public:
  void clear_color_argb4_value();
  ::uint32_t color_argb4_value() const;
  void set_color_argb4_value(::uint32_t value);
  private:
  ::uint32_t _internal_color_argb4_value() const;
  void _internal_set_color_argb4_value(::uint32_t value);
  public:

  // uint32 color_rgb4_value = 12;
  bool has_color_rgb4_value() const;
  private:
  bool _internal_has_color_rgb4_value() const;
  public:
  void clear_color_rgb4_value();
  ::uint32_t color_rgb4_value() const;
  void set_color_rgb4_value(::uint32_t value);
  private:
  ::uint32_t _internal_color_rgb4_value() const;
  void _internal_set_color_rgb4_value(::uint32_t value);
  public:

  // float dimension_value_deprecated = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_dimension_value_deprecated() const;
  private:
  bool _internal_has_dimension_value_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_dimension_value_deprecated();
  PROTOBUF_DEPRECATED float dimension_value_deprecated() const;
  PROTOBUF_DEPRECATED void set_dimension_value_deprecated(float value);
  private:
  float _internal_dimension_value_deprecated() const;
  void _internal_set_dimension_value_deprecated(float value);
  public:

  // float fraction_value_deprecated = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_fraction_value_deprecated() const;
  private:
  bool _internal_has_fraction_value_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_fraction_value_deprecated();
  PROTOBUF_DEPRECATED float fraction_value_deprecated() const;
  PROTOBUF_DEPRECATED void set_fraction_value_deprecated(float value);
  private:
  float _internal_fraction_value_deprecated() const;
  void _internal_set_fraction_value_deprecated(float value);
  public:

  void clear_oneof_value();
  OneofValueCase oneof_value_case() const;
  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive)
 private:
  class _Internal;
  void set_has_null_value();
  void set_has_empty_value();
  void set_has_float_value();
  void set_has_dimension_value();
  void set_has_fraction_value();
  void set_has_int_decimal_value();
  void set_has_int_hexadecimal_value();
  void set_has_boolean_value();
  void set_has_color_argb8_value();
  void set_has_color_rgb8_value();
  void set_has_color_argb4_value();
  void set_has_color_rgb4_value();
  void set_has_dimension_value_deprecated();
  void set_has_fraction_value_deprecated();

  inline bool has_oneof_value() const;
  inline void clear_has_oneof_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofValueUnion {
      constexpr OneofValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aapt::pb::Primitive_NullType* null_value_;
      ::aapt::pb::Primitive_EmptyType* empty_value_;
      float float_value_;
      ::uint32_t dimension_value_;
      ::uint32_t fraction_value_;
      ::int32_t int_decimal_value_;
      ::uint32_t int_hexadecimal_value_;
      bool boolean_value_;
      ::uint32_t color_argb8_value_;
      ::uint32_t color_rgb8_value_;
      ::uint32_t color_argb4_value_;
      ::uint32_t color_rgb4_value_;
      float dimension_value_deprecated_;
      float fraction_value_deprecated_;
    } oneof_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Attribute_Symbol final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Attribute.Symbol) */ {
 public:
  inline Attribute_Symbol() : Attribute_Symbol(nullptr) {}
  ~Attribute_Symbol() override;
  explicit PROTOBUF_CONSTEXPR Attribute_Symbol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribute_Symbol(const Attribute_Symbol& from);
  Attribute_Symbol(Attribute_Symbol&& from) noexcept
    : Attribute_Symbol() {
    *this = ::std::move(from);
  }

  inline Attribute_Symbol& operator=(const Attribute_Symbol& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Attribute_Symbol& operator=(Attribute_Symbol&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribute_Symbol& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribute_Symbol* internal_default_instance() {
    return reinterpret_cast<const Attribute_Symbol*>(
               &_Attribute_Symbol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Attribute_Symbol& a, Attribute_Symbol& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribute_Symbol* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribute_Symbol* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribute_Symbol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attribute_Symbol>(arena);
  }
  Attribute_Symbol* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribute_Symbol& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attribute_Symbol& from) {
    Attribute_Symbol::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribute_Symbol* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Attribute.Symbol";
  }
  protected:
  explicit Attribute_Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kNameFieldNumber = 3,
    kValueFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Reference name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::aapt::pb::Reference& name() const;
  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_name();
  ::aapt::pb::Reference* mutable_name();
  void set_allocated_name(::aapt::pb::Reference* name);
  private:
  const ::aapt::pb::Reference& _internal_name() const;
  ::aapt::pb::Reference* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::aapt::pb::Reference* name);
  ::aapt::pb::Reference* unsafe_arena_release_name();

  // uint32 value = 4;
  void clear_value();
  ::uint32_t value() const;
  void set_value(::uint32_t value);
  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);
  public:

  // uint32 type = 5;
  void clear_type();
  ::uint32_t type() const;
  void set_type(::uint32_t value);
  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute.Symbol)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::aapt::pb::Reference* name_;
    ::uint32_t value_;
    ::uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Attribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Attribute) */ {
 public:
  inline Attribute() : Attribute(nullptr) {}
  ~Attribute() override;
  explicit PROTOBUF_CONSTEXPR Attribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribute(const Attribute& from);
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(const Attribute& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Attribute& operator=(Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attribute>(arena);
  }
  Attribute* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attribute& from) {
    Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Attribute";
  }
  protected:
  explicit Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Attribute_Symbol Symbol;

  typedef Attribute_FormatFlags FormatFlags;
  static constexpr FormatFlags NONE =
    Attribute_FormatFlags_NONE;
  static constexpr FormatFlags ANY =
    Attribute_FormatFlags_ANY;
  static constexpr FormatFlags REFERENCE =
    Attribute_FormatFlags_REFERENCE;
  static constexpr FormatFlags STRING =
    Attribute_FormatFlags_STRING;
  static constexpr FormatFlags INTEGER =
    Attribute_FormatFlags_INTEGER;
  static constexpr FormatFlags BOOLEAN =
    Attribute_FormatFlags_BOOLEAN;
  static constexpr FormatFlags COLOR =
    Attribute_FormatFlags_COLOR;
  static constexpr FormatFlags FLOAT =
    Attribute_FormatFlags_FLOAT;
  static constexpr FormatFlags DIMENSION =
    Attribute_FormatFlags_DIMENSION;
  static constexpr FormatFlags FRACTION =
    Attribute_FormatFlags_FRACTION;
  static constexpr FormatFlags ENUM =
    Attribute_FormatFlags_ENUM;
  static constexpr FormatFlags FLAGS =
    Attribute_FormatFlags_FLAGS;
  static inline bool FormatFlags_IsValid(int value) {
    return Attribute_FormatFlags_IsValid(value);
  }
  static constexpr FormatFlags FormatFlags_MIN =
    Attribute_FormatFlags_FormatFlags_MIN;
  static constexpr FormatFlags FormatFlags_MAX =
    Attribute_FormatFlags_FormatFlags_MAX;
  static constexpr int FormatFlags_ARRAYSIZE =
    Attribute_FormatFlags_FormatFlags_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FormatFlags_descriptor() {
    return Attribute_FormatFlags_descriptor();
  }
  template<typename T>
  static inline const std::string& FormatFlags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FormatFlags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FormatFlags_Name.");
    return Attribute_FormatFlags_Name(enum_t_value);
  }
  static inline bool FormatFlags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FormatFlags* value) {
    return Attribute_FormatFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 4,
    kFormatFlagsFieldNumber = 1,
    kMinIntFieldNumber = 2,
    kMaxIntFieldNumber = 3,
  };
  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
  int symbol_size() const;
  private:
  int _internal_symbol_size() const;
  public:
  void clear_symbol();
  ::aapt::pb::Attribute_Symbol* mutable_symbol(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
      mutable_symbol();
  private:
  const ::aapt::pb::Attribute_Symbol& _internal_symbol(int index) const;
  ::aapt::pb::Attribute_Symbol* _internal_add_symbol();
  public:
  const ::aapt::pb::Attribute_Symbol& symbol(int index) const;
  ::aapt::pb::Attribute_Symbol* add_symbol();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
      symbol() const;

  // uint32 format_flags = 1;
  void clear_format_flags();
  ::uint32_t format_flags() const;
  void set_format_flags(::uint32_t value);
  private:
  ::uint32_t _internal_format_flags() const;
  void _internal_set_format_flags(::uint32_t value);
  public:

  // int32 min_int = 2;
  void clear_min_int();
  ::int32_t min_int() const;
  void set_min_int(::int32_t value);
  private:
  ::int32_t _internal_min_int() const;
  void _internal_set_min_int(::int32_t value);
  public:

  // int32 max_int = 3;
  void clear_max_int();
  ::int32_t max_int() const;
  void set_max_int(::int32_t value);
  private:
  ::int32_t _internal_max_int() const;
  void _internal_set_max_int(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol > symbol_;
    ::uint32_t format_flags_;
    ::int32_t min_int_;
    ::int32_t max_int_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Style_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Style.Entry) */ {
 public:
  inline Style_Entry() : Style_Entry(nullptr) {}
  ~Style_Entry() override;
  explicit PROTOBUF_CONSTEXPR Style_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Style_Entry(const Style_Entry& from);
  Style_Entry(Style_Entry&& from) noexcept
    : Style_Entry() {
    *this = ::std::move(from);
  }

  inline Style_Entry& operator=(const Style_Entry& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Style_Entry& operator=(Style_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Style_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Style_Entry* internal_default_instance() {
    return reinterpret_cast<const Style_Entry*>(
               &_Style_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Style_Entry& a, Style_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Style_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Style_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Style_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Style_Entry>(arena);
  }
  Style_Entry* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Style_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Style_Entry& from) {
    Style_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Style_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Style.Entry";
  }
  protected:
  explicit Style_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kKeyFieldNumber = 3,
    kItemFieldNumber = 4,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Reference key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::aapt::pb::Reference& key() const;
  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_key();
  ::aapt::pb::Reference* mutable_key();
  void set_allocated_key(::aapt::pb::Reference* key);
  private:
  const ::aapt::pb::Reference& _internal_key() const;
  ::aapt::pb::Reference* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::aapt::pb::Reference* key);
  ::aapt::pb::Reference* unsafe_arena_release_key();

  // .aapt.pb.Item item = 4;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::aapt::pb::Item& item() const;
  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
  ::aapt::pb::Item* mutable_item();
  void set_allocated_item(::aapt::pb::Item* item);
  private:
  const ::aapt::pb::Item& _internal_item() const;
  ::aapt::pb::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::aapt::pb::Item* item);
  ::aapt::pb::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:aapt.pb.Style.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::aapt::pb::Reference* key_;
    ::aapt::pb::Item* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Style final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Style) */ {
 public:
  inline Style() : Style(nullptr) {}
  ~Style() override;
  explicit PROTOBUF_CONSTEXPR Style(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Style(const Style& from);
  Style(Style&& from) noexcept
    : Style() {
    *this = ::std::move(from);
  }

  inline Style& operator=(const Style& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Style& operator=(Style&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Style& default_instance() {
    return *internal_default_instance();
  }
  static inline const Style* internal_default_instance() {
    return reinterpret_cast<const Style*>(
               &_Style_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Style& a, Style& b) {
    a.Swap(&b);
  }
  inline void Swap(Style* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Style* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Style* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Style>(arena);
  }
  Style* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Style& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Style& from) {
    Style::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Style* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Style";
  }
  protected:
  explicit Style(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Style_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 3,
    kParentFieldNumber = 1,
    kParentSourceFieldNumber = 2,
  };
  // repeated .aapt.pb.Style.Entry entry = 3;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::aapt::pb::Style_Entry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >*
      mutable_entry();
  private:
  const ::aapt::pb::Style_Entry& _internal_entry(int index) const;
  ::aapt::pb::Style_Entry* _internal_add_entry();
  public:
  const ::aapt::pb::Style_Entry& entry(int index) const;
  ::aapt::pb::Style_Entry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >&
      entry() const;

  // .aapt.pb.Reference parent = 1;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::aapt::pb::Reference& parent() const;
  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_parent();
  ::aapt::pb::Reference* mutable_parent();
  void set_allocated_parent(::aapt::pb::Reference* parent);
  private:
  const ::aapt::pb::Reference& _internal_parent() const;
  ::aapt::pb::Reference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::aapt::pb::Reference* parent);
  ::aapt::pb::Reference* unsafe_arena_release_parent();

  // .aapt.pb.Source parent_source = 2;
  bool has_parent_source() const;
  private:
  bool _internal_has_parent_source() const;
  public:
  void clear_parent_source();
  const ::aapt::pb::Source& parent_source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_parent_source();
  ::aapt::pb::Source* mutable_parent_source();
  void set_allocated_parent_source(::aapt::pb::Source* parent_source);
  private:
  const ::aapt::pb::Source& _internal_parent_source() const;
  ::aapt::pb::Source* _internal_mutable_parent_source();
  public:
  void unsafe_arena_set_allocated_parent_source(
      ::aapt::pb::Source* parent_source);
  ::aapt::pb::Source* unsafe_arena_release_parent_source();

  // @@protoc_insertion_point(class_scope:aapt.pb.Style)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry > entry_;
    ::aapt::pb::Reference* parent_;
    ::aapt::pb::Source* parent_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Styleable_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Styleable.Entry) */ {
 public:
  inline Styleable_Entry() : Styleable_Entry(nullptr) {}
  ~Styleable_Entry() override;
  explicit PROTOBUF_CONSTEXPR Styleable_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Styleable_Entry(const Styleable_Entry& from);
  Styleable_Entry(Styleable_Entry&& from) noexcept
    : Styleable_Entry() {
    *this = ::std::move(from);
  }

  inline Styleable_Entry& operator=(const Styleable_Entry& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Styleable_Entry& operator=(Styleable_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Styleable_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Styleable_Entry* internal_default_instance() {
    return reinterpret_cast<const Styleable_Entry*>(
               &_Styleable_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Styleable_Entry& a, Styleable_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Styleable_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Styleable_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Styleable_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Styleable_Entry>(arena);
  }
  Styleable_Entry* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Styleable_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Styleable_Entry& from) {
    Styleable_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Styleable_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Styleable.Entry";
  }
  protected:
  explicit Styleable_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kAttrFieldNumber = 3,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Reference attr = 3;
  bool has_attr() const;
  private:
  bool _internal_has_attr() const;
  public:
  void clear_attr();
  const ::aapt::pb::Reference& attr() const;
  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_attr();
  ::aapt::pb::Reference* mutable_attr();
  void set_allocated_attr(::aapt::pb::Reference* attr);
  private:
  const ::aapt::pb::Reference& _internal_attr() const;
  ::aapt::pb::Reference* _internal_mutable_attr();
  public:
  void unsafe_arena_set_allocated_attr(
      ::aapt::pb::Reference* attr);
  ::aapt::pb::Reference* unsafe_arena_release_attr();

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::aapt::pb::Reference* attr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Styleable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Styleable) */ {
 public:
  inline Styleable() : Styleable(nullptr) {}
  ~Styleable() override;
  explicit PROTOBUF_CONSTEXPR Styleable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Styleable(const Styleable& from);
  Styleable(Styleable&& from) noexcept
    : Styleable() {
    *this = ::std::move(from);
  }

  inline Styleable& operator=(const Styleable& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Styleable& operator=(Styleable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Styleable& default_instance() {
    return *internal_default_instance();
  }
  static inline const Styleable* internal_default_instance() {
    return reinterpret_cast<const Styleable*>(
               &_Styleable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Styleable& a, Styleable& b) {
    a.Swap(&b);
  }
  inline void Swap(Styleable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Styleable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Styleable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Styleable>(arena);
  }
  Styleable* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Styleable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Styleable& from) {
    Styleable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Styleable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Styleable";
  }
  protected:
  explicit Styleable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Styleable_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .aapt.pb.Styleable.Entry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::aapt::pb::Styleable_Entry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
      mutable_entry();
  private:
  const ::aapt::pb::Styleable_Entry& _internal_entry(int index) const;
  ::aapt::pb::Styleable_Entry* _internal_add_entry();
  public:
  const ::aapt::pb::Styleable_Entry& entry(int index) const;
  ::aapt::pb::Styleable_Entry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Array_Element final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Array.Element) */ {
 public:
  inline Array_Element() : Array_Element(nullptr) {}
  ~Array_Element() override;
  explicit PROTOBUF_CONSTEXPR Array_Element(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array_Element(const Array_Element& from);
  Array_Element(Array_Element&& from) noexcept
    : Array_Element() {
    *this = ::std::move(from);
  }

  inline Array_Element& operator=(const Array_Element& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Array_Element& operator=(Array_Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array_Element& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array_Element* internal_default_instance() {
    return reinterpret_cast<const Array_Element*>(
               &_Array_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Array_Element& a, Array_Element& b) {
    a.Swap(&b);
  }
  inline void Swap(Array_Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array_Element* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array_Element* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Array_Element>(arena);
  }
  Array_Element* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Array_Element& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Array_Element& from) {
    Array_Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Array_Element* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Array.Element";
  }
  protected:
  explicit Array_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kItemFieldNumber = 3,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Item item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::aapt::pb::Item& item() const;
  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
  ::aapt::pb::Item* mutable_item();
  void set_allocated_item(::aapt::pb::Item* item);
  private:
  const ::aapt::pb::Item& _internal_item() const;
  ::aapt::pb::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::aapt::pb::Item* item);
  ::aapt::pb::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:aapt.pb.Array.Element)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::aapt::pb::Item* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Array) */ {
 public:
  inline Array() : Array(nullptr) {}
  ~Array() override;
  explicit PROTOBUF_CONSTEXPR Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array(const Array& from);
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(const Array& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  Array* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Array& from) {
    Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Array";
  }
  protected:
  explicit Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Array_Element Element;

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
  };
  // repeated .aapt.pb.Array.Element element = 1;
  int element_size() const;
  private:
  int _internal_element_size() const;
  public:
  void clear_element();
  ::aapt::pb::Array_Element* mutable_element(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >*
      mutable_element();
  private:
  const ::aapt::pb::Array_Element& _internal_element(int index) const;
  ::aapt::pb::Array_Element* _internal_add_element();
  public:
  const ::aapt::pb::Array_Element& element(int index) const;
  ::aapt::pb::Array_Element* add_element();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >&
      element() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element > element_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Plural_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Plural.Entry) */ {
 public:
  inline Plural_Entry() : Plural_Entry(nullptr) {}
  ~Plural_Entry() override;
  explicit PROTOBUF_CONSTEXPR Plural_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plural_Entry(const Plural_Entry& from);
  Plural_Entry(Plural_Entry&& from) noexcept
    : Plural_Entry() {
    *this = ::std::move(from);
  }

  inline Plural_Entry& operator=(const Plural_Entry& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Plural_Entry& operator=(Plural_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plural_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plural_Entry* internal_default_instance() {
    return reinterpret_cast<const Plural_Entry*>(
               &_Plural_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Plural_Entry& a, Plural_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Plural_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plural_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plural_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plural_Entry>(arena);
  }
  Plural_Entry* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plural_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Plural_Entry& from) {
    Plural_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plural_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Plural.Entry";
  }
  protected:
  explicit Plural_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kSourceFieldNumber = 1,
    kItemFieldNumber = 4,
    kArityFieldNumber = 3,
  };
  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .aapt.pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::Source& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
  ::aapt::pb::Source* mutable_source();
  void set_allocated_source(::aapt::pb::Source* source);
  private:
  const ::aapt::pb::Source& _internal_source() const;
  ::aapt::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::Source* source);
  ::aapt::pb::Source* unsafe_arena_release_source();

  // .aapt.pb.Item item = 4;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::aapt::pb::Item& item() const;
  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
  ::aapt::pb::Item* mutable_item();
  void set_allocated_item(::aapt::pb::Item* item);
  private:
  const ::aapt::pb::Item& _internal_item() const;
  ::aapt::pb::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::aapt::pb::Item* item);
  ::aapt::pb::Item* unsafe_arena_release_item();

  // .aapt.pb.Plural.Arity arity = 3;
  void clear_arity();
  ::aapt::pb::Plural_Arity arity() const;
  void set_arity(::aapt::pb::Plural_Arity value);
  private:
  ::aapt::pb::Plural_Arity _internal_arity() const;
  void _internal_set_arity(::aapt::pb::Plural_Arity value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::aapt::pb::Source* source_;
    ::aapt::pb::Item* item_;
    int arity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class Plural final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Plural) */ {
 public:
  inline Plural() : Plural(nullptr) {}
  ~Plural() override;
  explicit PROTOBUF_CONSTEXPR Plural(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plural(const Plural& from);
  Plural(Plural&& from) noexcept
    : Plural() {
    *this = ::std::move(from);
  }

  inline Plural& operator=(const Plural& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline Plural& operator=(Plural&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plural& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plural* internal_default_instance() {
    return reinterpret_cast<const Plural*>(
               &_Plural_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Plural& a, Plural& b) {
    a.Swap(&b);
  }
  inline void Swap(Plural* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plural* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plural* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plural>(arena);
  }
  Plural* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plural& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Plural& from) {
    Plural::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plural* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.Plural";
  }
  protected:
  explicit Plural(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Plural_Entry Entry;

  typedef Plural_Arity Arity;
  static constexpr Arity ZERO =
    Plural_Arity_ZERO;
  static constexpr Arity ONE =
    Plural_Arity_ONE;
  static constexpr Arity TWO =
    Plural_Arity_TWO;
  static constexpr Arity FEW =
    Plural_Arity_FEW;
  static constexpr Arity MANY =
    Plural_Arity_MANY;
  static constexpr Arity OTHER =
    Plural_Arity_OTHER;
  static inline bool Arity_IsValid(int value) {
    return Plural_Arity_IsValid(value);
  }
  static constexpr Arity Arity_MIN =
    Plural_Arity_Arity_MIN;
  static constexpr Arity Arity_MAX =
    Plural_Arity_Arity_MAX;
  static constexpr int Arity_ARRAYSIZE =
    Plural_Arity_Arity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Arity_descriptor() {
    return Plural_Arity_descriptor();
  }
  template<typename T>
  static inline const std::string& Arity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Arity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Arity_Name.");
    return Plural_Arity_Name(enum_t_value);
  }
  static inline bool Arity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Arity* value) {
    return Plural_Arity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .aapt.pb.Plural.Entry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::aapt::pb::Plural_Entry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
      mutable_entry();
  private:
  const ::aapt::pb::Plural_Entry& _internal_entry(int index) const;
  ::aapt::pb::Plural_Entry* _internal_add_entry();
  public:
  const ::aapt::pb::Plural_Entry& entry(int index) const;
  ::aapt::pb::Plural_Entry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class XmlNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlNode) */ {
 public:
  inline XmlNode() : XmlNode(nullptr) {}
  ~XmlNode() override;
  explicit PROTOBUF_CONSTEXPR XmlNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XmlNode(const XmlNode& from);
  XmlNode(XmlNode&& from) noexcept
    : XmlNode() {
    *this = ::std::move(from);
  }

  inline XmlNode& operator=(const XmlNode& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline XmlNode& operator=(XmlNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XmlNode& default_instance() {
    return *internal_default_instance();
  }
  enum NodeCase {
    kElement = 1,
    kText = 2,
    NODE_NOT_SET = 0,
  };

  static inline const XmlNode* internal_default_instance() {
    return reinterpret_cast<const XmlNode*>(
               &_XmlNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(XmlNode& a, XmlNode& b) {
    a.Swap(&b);
  }
  inline void Swap(XmlNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XmlNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XmlNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XmlNode>(arena);
  }
  XmlNode* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XmlNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XmlNode& from) {
    XmlNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XmlNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.XmlNode";
  }
  protected:
  explicit XmlNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 3,
    kElementFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // .aapt.pb.SourcePosition source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::SourcePosition& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
  ::aapt::pb::SourcePosition* mutable_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);
  private:
  const ::aapt::pb::SourcePosition& _internal_source() const;
  ::aapt::pb::SourcePosition* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::SourcePosition* source);
  ::aapt::pb::SourcePosition* unsafe_arena_release_source();

  // .aapt.pb.XmlElement element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::aapt::pb::XmlElement& element() const;
  PROTOBUF_NODISCARD ::aapt::pb::XmlElement* release_element();
  ::aapt::pb::XmlElement* mutable_element();
  void set_allocated_element(::aapt::pb::XmlElement* element);
  private:
  const ::aapt::pb::XmlElement& _internal_element() const;
  ::aapt::pb::XmlElement* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::aapt::pb::XmlElement* element);
  ::aapt::pb::XmlElement* unsafe_arena_release_element();

  // string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNode)
 private:
  class _Internal;
  void set_has_element();
  void set_has_text();

  inline bool has_node() const;
  inline void clear_has_node();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::aapt::pb::SourcePosition* source_;
    union NodeUnion {
      constexpr NodeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aapt::pb::XmlElement* element_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    } node_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class XmlElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlElement) */ {
 public:
  inline XmlElement() : XmlElement(nullptr) {}
  ~XmlElement() override;
  explicit PROTOBUF_CONSTEXPR XmlElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XmlElement(const XmlElement& from);
  XmlElement(XmlElement&& from) noexcept
    : XmlElement() {
    *this = ::std::move(from);
  }

  inline XmlElement& operator=(const XmlElement& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline XmlElement& operator=(XmlElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XmlElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const XmlElement* internal_default_instance() {
    return reinterpret_cast<const XmlElement*>(
               &_XmlElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(XmlElement& a, XmlElement& b) {
    a.Swap(&b);
  }
  inline void Swap(XmlElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XmlElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XmlElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XmlElement>(arena);
  }
  XmlElement* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XmlElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XmlElement& from) {
    XmlElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XmlElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.XmlElement";
  }
  protected:
  explicit XmlElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceDeclarationFieldNumber = 1,
    kAttributeFieldNumber = 4,
    kChildFieldNumber = 5,
    kNamespaceUriFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
  int namespace_declaration_size() const;
  private:
  int _internal_namespace_declaration_size() const;
  public:
  void clear_namespace_declaration();
  ::aapt::pb::XmlNamespace* mutable_namespace_declaration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
      mutable_namespace_declaration();
  private:
  const ::aapt::pb::XmlNamespace& _internal_namespace_declaration(int index) const;
  ::aapt::pb::XmlNamespace* _internal_add_namespace_declaration();
  public:
  const ::aapt::pb::XmlNamespace& namespace_declaration(int index) const;
  ::aapt::pb::XmlNamespace* add_namespace_declaration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
      namespace_declaration() const;

  // repeated .aapt.pb.XmlAttribute attribute = 4;
  int attribute_size() const;
  private:
  int _internal_attribute_size() const;
  public:
  void clear_attribute();
  ::aapt::pb::XmlAttribute* mutable_attribute(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
      mutable_attribute();
  private:
  const ::aapt::pb::XmlAttribute& _internal_attribute(int index) const;
  ::aapt::pb::XmlAttribute* _internal_add_attribute();
  public:
  const ::aapt::pb::XmlAttribute& attribute(int index) const;
  ::aapt::pb::XmlAttribute* add_attribute();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
      attribute() const;

  // repeated .aapt.pb.XmlNode child = 5;
  int child_size() const;
  private:
  int _internal_child_size() const;
  public:
  void clear_child();
  ::aapt::pb::XmlNode* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >*
      mutable_child();
  private:
  const ::aapt::pb::XmlNode& _internal_child(int index) const;
  ::aapt::pb::XmlNode* _internal_add_child();
  public:
  const ::aapt::pb::XmlNode& child(int index) const;
  ::aapt::pb::XmlNode* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >&
      child() const;

  // string namespace_uri = 2;
  void clear_namespace_uri();
  const std::string& namespace_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_uri();
  PROTOBUF_NODISCARD std::string* release_namespace_uri();
  void set_allocated_namespace_uri(std::string* namespace_uri);
  private:
  const std::string& _internal_namespace_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_uri(const std::string& value);
  std::string* _internal_mutable_namespace_uri();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace > namespace_declaration_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute > attribute_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode > child_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class XmlNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlNamespace) */ {
 public:
  inline XmlNamespace() : XmlNamespace(nullptr) {}
  ~XmlNamespace() override;
  explicit PROTOBUF_CONSTEXPR XmlNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XmlNamespace(const XmlNamespace& from);
  XmlNamespace(XmlNamespace&& from) noexcept
    : XmlNamespace() {
    *this = ::std::move(from);
  }

  inline XmlNamespace& operator=(const XmlNamespace& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline XmlNamespace& operator=(XmlNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XmlNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const XmlNamespace* internal_default_instance() {
    return reinterpret_cast<const XmlNamespace*>(
               &_XmlNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(XmlNamespace& a, XmlNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(XmlNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XmlNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XmlNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XmlNamespace>(arena);
  }
  XmlNamespace* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XmlNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XmlNamespace& from) {
    XmlNamespace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XmlNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.XmlNamespace";
  }
  protected:
  explicit XmlNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
    kUriFieldNumber = 2,
    kSourceFieldNumber = 3,
  };
  // string prefix = 1;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string uri = 2;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .aapt.pb.SourcePosition source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::SourcePosition& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
  ::aapt::pb::SourcePosition* mutable_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);
  private:
  const ::aapt::pb::SourcePosition& _internal_source() const;
  ::aapt::pb::SourcePosition* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::SourcePosition* source);
  ::aapt::pb::SourcePosition* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::aapt::pb::SourcePosition* source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// -------------------------------------------------------------------

class XmlAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlAttribute) */ {
 public:
  inline XmlAttribute() : XmlAttribute(nullptr) {}
  ~XmlAttribute() override;
  explicit PROTOBUF_CONSTEXPR XmlAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XmlAttribute(const XmlAttribute& from);
  XmlAttribute(XmlAttribute&& from) noexcept
    : XmlAttribute() {
    *this = ::std::move(from);
  }

  inline XmlAttribute& operator=(const XmlAttribute& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline XmlAttribute& operator=(XmlAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XmlAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const XmlAttribute* internal_default_instance() {
    return reinterpret_cast<const XmlAttribute*>(
               &_XmlAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(XmlAttribute& a, XmlAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(XmlAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XmlAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XmlAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XmlAttribute>(arena);
  }
  XmlAttribute* New() const {
    return New(nullptr);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XmlAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XmlAttribute& from) {
    XmlAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XmlAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aapt.pb.XmlAttribute";
  }
  protected:
  explicit XmlAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceUriFieldNumber = 1,
    kNameFieldNumber = 2,
    kValueFieldNumber = 3,
    kSourceFieldNumber = 4,
    kCompiledItemFieldNumber = 6,
    kResourceIdFieldNumber = 5,
  };
  // string namespace_uri = 1;
  void clear_namespace_uri();
  const std::string& namespace_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_uri();
  PROTOBUF_NODISCARD std::string* release_namespace_uri();
  void set_allocated_namespace_uri(std::string* namespace_uri);
  private:
  const std::string& _internal_namespace_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_uri(const std::string& value);
  std::string* _internal_mutable_namespace_uri();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .aapt.pb.SourcePosition source = 4;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::aapt::pb::SourcePosition& source() const;
  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
  ::aapt::pb::SourcePosition* mutable_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);
  private:
  const ::aapt::pb::SourcePosition& _internal_source() const;
  ::aapt::pb::SourcePosition* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::aapt::pb::SourcePosition* source);
  ::aapt::pb::SourcePosition* unsafe_arena_release_source();

  // .aapt.pb.Item compiled_item = 6;
  bool has_compiled_item() const;
  private:
  bool _internal_has_compiled_item() const;
  public:
  void clear_compiled_item();
  const ::aapt::pb::Item& compiled_item() const;
  PROTOBUF_NODISCARD ::aapt::pb::Item* release_compiled_item();
  ::aapt::pb::Item* mutable_compiled_item();
  void set_allocated_compiled_item(::aapt::pb::Item* compiled_item);
  private:
  const ::aapt::pb::Item& _internal_compiled_item() const;
  ::aapt::pb::Item* _internal_mutable_compiled_item();
  public:
  void unsafe_arena_set_allocated_compiled_item(
      ::aapt::pb::Item* compiled_item);
  ::aapt::pb::Item* unsafe_arena_release_compiled_item();

  // uint32 resource_id = 5;
  void clear_resource_id();
  ::uint32_t resource_id() const;
  void set_resource_id(::uint32_t value);
  private:
  ::uint32_t _internal_resource_id() const;
  void _internal_set_resource_id(::uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::aapt::pb::SourcePosition* source_;
    ::aapt::pb::Item* compiled_item_;
    ::uint32_t resource_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Resources_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StringPool

// bytes data = 1;
inline void StringPool::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StringPool::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StringPool.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringPool::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.StringPool.data)
}
inline std::string* StringPool::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StringPool.data)
  return _s;
}
inline const std::string& StringPool::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StringPool::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StringPool::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StringPool::release_data() {
  // @@protoc_insertion_point(field_release:aapt.pb.StringPool.data)
  return _impl_.data_.Release();
}
inline void StringPool::set_allocated_data(std::string* data) {
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StringPool.data)
}

// -------------------------------------------------------------------

// SourcePosition

// uint32 line_number = 1;
inline void SourcePosition::clear_line_number() {
  _impl_.line_number_ = 0u;
}
inline ::uint32_t SourcePosition::_internal_line_number() const {
  return _impl_.line_number_;
}
inline ::uint32_t SourcePosition::line_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.line_number)
  return _internal_line_number();
}
inline void SourcePosition::_internal_set_line_number(::uint32_t value) {
  
  _impl_.line_number_ = value;
}
inline void SourcePosition::set_line_number(::uint32_t value) {
  _internal_set_line_number(value);
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.line_number)
}

// uint32 column_number = 2;
inline void SourcePosition::clear_column_number() {
  _impl_.column_number_ = 0u;
}
inline ::uint32_t SourcePosition::_internal_column_number() const {
  return _impl_.column_number_;
}
inline ::uint32_t SourcePosition::column_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.column_number)
  return _internal_column_number();
}
inline void SourcePosition::_internal_set_column_number(::uint32_t value) {
  
  _impl_.column_number_ = value;
}
inline void SourcePosition::set_column_number(::uint32_t value) {
  _internal_set_column_number(value);
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.column_number)
}

// -------------------------------------------------------------------

// Source

// uint32 path_idx = 1;
inline void Source::clear_path_idx() {
  _impl_.path_idx_ = 0u;
}
inline ::uint32_t Source::_internal_path_idx() const {
  return _impl_.path_idx_;
}
inline ::uint32_t Source::path_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.path_idx)
  return _internal_path_idx();
}
inline void Source::_internal_set_path_idx(::uint32_t value) {
  
  _impl_.path_idx_ = value;
}
inline void Source::set_path_idx(::uint32_t value) {
  _internal_set_path_idx(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Source.path_idx)
}

// .aapt.pb.SourcePosition position = 2;
inline bool Source::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Source::has_position() const {
  return _internal_has_position();
}
inline void Source::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::aapt::pb::SourcePosition& Source::_internal_position() const {
  const ::aapt::pb::SourcePosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
      ::aapt::pb::_SourcePosition_default_instance_);
}
inline const ::aapt::pb::SourcePosition& Source::position() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.position)
  return _internal_position();
}
inline void Source::unsafe_arena_set_allocated_position(
    ::aapt::pb::SourcePosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Source.position)
}
inline ::aapt::pb::SourcePosition* Source::release_position() {
  
  ::aapt::pb::SourcePosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::SourcePosition* Source::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:aapt.pb.Source.position)
  
  ::aapt::pb::SourcePosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::aapt::pb::SourcePosition* Source::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::aapt::pb::SourcePosition* Source::mutable_position() {
  ::aapt::pb::SourcePosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Source.position)
  return _msg;
}
inline void Source::set_allocated_position(::aapt::pb::SourcePosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Source.position)
}

// -------------------------------------------------------------------

// ToolFingerprint

// string tool = 1;
inline void ToolFingerprint::clear_tool() {
  _impl_.tool_.ClearToEmpty();
}
inline const std::string& ToolFingerprint::tool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ToolFingerprint.tool)
  return _internal_tool();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolFingerprint::set_tool(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.ToolFingerprint.tool)
}
inline std::string* ToolFingerprint::mutable_tool() {
  std::string* _s = _internal_mutable_tool();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ToolFingerprint.tool)
  return _s;
}
inline const std::string& ToolFingerprint::_internal_tool() const {
  return _impl_.tool_.Get();
}
inline void ToolFingerprint::_internal_set_tool(const std::string& value) {
  
  _impl_.tool_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolFingerprint::_internal_mutable_tool() {
  
  return _impl_.tool_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolFingerprint::release_tool() {
  // @@protoc_insertion_point(field_release:aapt.pb.ToolFingerprint.tool)
  return _impl_.tool_.Release();
}
inline void ToolFingerprint::set_allocated_tool(std::string* tool) {
  _impl_.tool_.SetAllocated(tool, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_.IsDefault()) {
    _impl_.tool_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ToolFingerprint.tool)
}

// string version = 2;
inline void ToolFingerprint::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ToolFingerprint::version() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ToolFingerprint.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolFingerprint::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.ToolFingerprint.version)
}
inline std::string* ToolFingerprint::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ToolFingerprint.version)
  return _s;
}
inline const std::string& ToolFingerprint::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ToolFingerprint::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolFingerprint::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolFingerprint::release_version() {
  // @@protoc_insertion_point(field_release:aapt.pb.ToolFingerprint.version)
  return _impl_.version_.Release();
}
inline void ToolFingerprint::set_allocated_version(std::string* version) {
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ToolFingerprint.version)
}

// -------------------------------------------------------------------

// ResourceTable

// .aapt.pb.StringPool source_pool = 1;
inline bool ResourceTable::_internal_has_source_pool() const {
  return this != internal_default_instance() && _impl_.source_pool_ != nullptr;
}
inline bool ResourceTable::has_source_pool() const {
  return _internal_has_source_pool();
}
inline void ResourceTable::clear_source_pool() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_pool_ != nullptr) {
    delete _impl_.source_pool_;
  }
  _impl_.source_pool_ = nullptr;
}
inline const ::aapt::pb::StringPool& ResourceTable::_internal_source_pool() const {
  const ::aapt::pb::StringPool* p = _impl_.source_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::StringPool&>(
      ::aapt::pb::_StringPool_default_instance_);
}
inline const ::aapt::pb::StringPool& ResourceTable::source_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.source_pool)
  return _internal_source_pool();
}
inline void ResourceTable::unsafe_arena_set_allocated_source_pool(
    ::aapt::pb::StringPool* source_pool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_pool_);
  }
  _impl_.source_pool_ = source_pool;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ResourceTable.source_pool)
}
inline ::aapt::pb::StringPool* ResourceTable::release_source_pool() {
  
  ::aapt::pb::StringPool* temp = _impl_.source_pool_;
  _impl_.source_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::StringPool* ResourceTable::unsafe_arena_release_source_pool() {
  // @@protoc_insertion_point(field_release:aapt.pb.ResourceTable.source_pool)
  
  ::aapt::pb::StringPool* temp = _impl_.source_pool_;
  _impl_.source_pool_ = nullptr;
  return temp;
}
inline ::aapt::pb::StringPool* ResourceTable::_internal_mutable_source_pool() {
  
  if (_impl_.source_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::StringPool>(GetArenaForAllocation());
    _impl_.source_pool_ = p;
  }
  return _impl_.source_pool_;
}
inline ::aapt::pb::StringPool* ResourceTable::mutable_source_pool() {
  ::aapt::pb::StringPool* _msg = _internal_mutable_source_pool();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.source_pool)
  return _msg;
}
inline void ResourceTable::set_allocated_source_pool(::aapt::pb::StringPool* source_pool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_pool_;
  }
  if (source_pool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_pool);
    if (message_arena != submessage_arena) {
      source_pool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_pool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_pool_ = source_pool;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.source_pool)
}

// repeated .aapt.pb.Package package = 2;
inline int ResourceTable::_internal_package_size() const {
  return _impl_.package_.size();
}
inline int ResourceTable::package_size() const {
  return _internal_package_size();
}
inline void ResourceTable::clear_package() {
  _impl_.package_.Clear();
}
inline ::aapt::pb::Package* ResourceTable::mutable_package(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.package)
  return _impl_.package_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >*
ResourceTable::mutable_package() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.package)
  return &_impl_.package_;
}
inline const ::aapt::pb::Package& ResourceTable::_internal_package(int index) const {
  return _impl_.package_.Get(index);
}
inline const ::aapt::pb::Package& ResourceTable::package(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.package)
  return _internal_package(index);
}
inline ::aapt::pb::Package* ResourceTable::_internal_add_package() {
  return _impl_.package_.Add();
}
inline ::aapt::pb::Package* ResourceTable::add_package() {
  ::aapt::pb::Package* _add = _internal_add_package();
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.package)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >&
ResourceTable::package() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.package)
  return _impl_.package_;
}

// repeated .aapt.pb.Overlayable overlayable = 3;
inline int ResourceTable::_internal_overlayable_size() const {
  return _impl_.overlayable_.size();
}
inline int ResourceTable::overlayable_size() const {
  return _internal_overlayable_size();
}
inline void ResourceTable::clear_overlayable() {
  _impl_.overlayable_.Clear();
}
inline ::aapt::pb::Overlayable* ResourceTable::mutable_overlayable(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.overlayable)
  return _impl_.overlayable_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >*
ResourceTable::mutable_overlayable() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.overlayable)
  return &_impl_.overlayable_;
}
inline const ::aapt::pb::Overlayable& ResourceTable::_internal_overlayable(int index) const {
  return _impl_.overlayable_.Get(index);
}
inline const ::aapt::pb::Overlayable& ResourceTable::overlayable(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.overlayable)
  return _internal_overlayable(index);
}
inline ::aapt::pb::Overlayable* ResourceTable::_internal_add_overlayable() {
  return _impl_.overlayable_.Add();
}
inline ::aapt::pb::Overlayable* ResourceTable::add_overlayable() {
  ::aapt::pb::Overlayable* _add = _internal_add_overlayable();
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.overlayable)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >&
ResourceTable::overlayable() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.overlayable)
  return _impl_.overlayable_;
}

// repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
inline int ResourceTable::_internal_tool_fingerprint_size() const {
  return _impl_.tool_fingerprint_.size();
}
inline int ResourceTable::tool_fingerprint_size() const {
  return _internal_tool_fingerprint_size();
}
inline void ResourceTable::clear_tool_fingerprint() {
  _impl_.tool_fingerprint_.Clear();
}
inline ::aapt::pb::ToolFingerprint* ResourceTable::mutable_tool_fingerprint(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.tool_fingerprint)
  return _impl_.tool_fingerprint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >*
ResourceTable::mutable_tool_fingerprint() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.tool_fingerprint)
  return &_impl_.tool_fingerprint_;
}
inline const ::aapt::pb::ToolFingerprint& ResourceTable::_internal_tool_fingerprint(int index) const {
  return _impl_.tool_fingerprint_.Get(index);
}
inline const ::aapt::pb::ToolFingerprint& ResourceTable::tool_fingerprint(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.tool_fingerprint)
  return _internal_tool_fingerprint(index);
}
inline ::aapt::pb::ToolFingerprint* ResourceTable::_internal_add_tool_fingerprint() {
  return _impl_.tool_fingerprint_.Add();
}
inline ::aapt::pb::ToolFingerprint* ResourceTable::add_tool_fingerprint() {
  ::aapt::pb::ToolFingerprint* _add = _internal_add_tool_fingerprint();
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.tool_fingerprint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >&
ResourceTable::tool_fingerprint() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.tool_fingerprint)
  return _impl_.tool_fingerprint_;
}

// -------------------------------------------------------------------

// PackageId

// uint32 id = 1;
inline void PackageId::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t PackageId::_internal_id() const {
  return _impl_.id_;
}
inline ::uint32_t PackageId::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.PackageId.id)
  return _internal_id();
}
inline void PackageId::_internal_set_id(::uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PackageId::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aapt.pb.PackageId.id)
}

// -------------------------------------------------------------------

// Package

// .aapt.pb.PackageId package_id = 1;
inline bool Package::_internal_has_package_id() const {
  return this != internal_default_instance() && _impl_.package_id_ != nullptr;
}
inline bool Package::has_package_id() const {
  return _internal_has_package_id();
}
inline void Package::clear_package_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.package_id_ != nullptr) {
    delete _impl_.package_id_;
  }
  _impl_.package_id_ = nullptr;
}
inline const ::aapt::pb::PackageId& Package::_internal_package_id() const {
  const ::aapt::pb::PackageId* p = _impl_.package_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::PackageId&>(
      ::aapt::pb::_PackageId_default_instance_);
}
inline const ::aapt::pb::PackageId& Package::package_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_id)
  return _internal_package_id();
}
inline void Package::unsafe_arena_set_allocated_package_id(
    ::aapt::pb::PackageId* package_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.package_id_);
  }
  _impl_.package_id_ = package_id;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Package.package_id)
}
inline ::aapt::pb::PackageId* Package::release_package_id() {
  
  ::aapt::pb::PackageId* temp = _impl_.package_id_;
  _impl_.package_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::PackageId* Package::unsafe_arena_release_package_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_id)
  
  ::aapt::pb::PackageId* temp = _impl_.package_id_;
  _impl_.package_id_ = nullptr;
  return temp;
}
inline ::aapt::pb::PackageId* Package::_internal_mutable_package_id() {
  
  if (_impl_.package_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::PackageId>(GetArenaForAllocation());
    _impl_.package_id_ = p;
  }
  return _impl_.package_id_;
}
inline ::aapt::pb::PackageId* Package::mutable_package_id() {
  ::aapt::pb::PackageId* _msg = _internal_mutable_package_id();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_id)
  return _msg;
}
inline void Package::set_allocated_package_id(::aapt::pb::PackageId* package_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.package_id_;
  }
  if (package_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(package_id);
    if (message_arena != submessage_arena) {
      package_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, package_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.package_id_ = package_id;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_id)
}

// string package_name = 2;
inline void Package::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
}
inline const std::string& Package::package_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_package_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_name)
}
inline std::string* Package::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_name)
  return _s;
}
inline const std::string& Package::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void Package::_internal_set_package_name(const std::string& value) {
  
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_package_name() {
  
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Package::release_package_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_name)
  return _impl_.package_name_.Release();
}
inline void Package::set_allocated_package_name(std::string* package_name) {
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_name)
}

// repeated .aapt.pb.Type type = 3;
inline int Package::_internal_type_size() const {
  return _impl_.type_.size();
}
inline int Package::type_size() const {
  return _internal_type_size();
}
inline void Package::clear_type() {
  _impl_.type_.Clear();
}
inline ::aapt::pb::Type* Package::mutable_type(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.type)
  return _impl_.type_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >*
Package::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Package.type)
  return &_impl_.type_;
}
inline const ::aapt::pb::Type& Package::_internal_type(int index) const {
  return _impl_.type_.Get(index);
}
inline const ::aapt::pb::Type& Package::type(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.type)
  return _internal_type(index);
}
inline ::aapt::pb::Type* Package::_internal_add_type() {
  return _impl_.type_.Add();
}
inline ::aapt::pb::Type* Package::add_type() {
  ::aapt::pb::Type* _add = _internal_add_type();
  // @@protoc_insertion_point(field_add:aapt.pb.Package.type)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >&
Package::type() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Package.type)
  return _impl_.type_;
}

// -------------------------------------------------------------------

// TypeId

// uint32 id = 1;
inline void TypeId::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t TypeId::_internal_id() const {
  return _impl_.id_;
}
inline ::uint32_t TypeId::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.TypeId.id)
  return _internal_id();
}
inline void TypeId::_internal_set_id(::uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TypeId::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aapt.pb.TypeId.id)
}

// -------------------------------------------------------------------

// Type

// .aapt.pb.TypeId type_id = 1;
inline bool Type::_internal_has_type_id() const {
  return this != internal_default_instance() && _impl_.type_id_ != nullptr;
}
inline bool Type::has_type_id() const {
  return _internal_has_type_id();
}
inline void Type::clear_type_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.type_id_ != nullptr) {
    delete _impl_.type_id_;
  }
  _impl_.type_id_ = nullptr;
}
inline const ::aapt::pb::TypeId& Type::_internal_type_id() const {
  const ::aapt::pb::TypeId* p = _impl_.type_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::TypeId&>(
      ::aapt::pb::_TypeId_default_instance_);
}
inline const ::aapt::pb::TypeId& Type::type_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.type_id)
  return _internal_type_id();
}
inline void Type::unsafe_arena_set_allocated_type_id(
    ::aapt::pb::TypeId* type_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_id_);
  }
  _impl_.type_id_ = type_id;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Type.type_id)
}
inline ::aapt::pb::TypeId* Type::release_type_id() {
  
  ::aapt::pb::TypeId* temp = _impl_.type_id_;
  _impl_.type_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::TypeId* Type::unsafe_arena_release_type_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Type.type_id)
  
  ::aapt::pb::TypeId* temp = _impl_.type_id_;
  _impl_.type_id_ = nullptr;
  return temp;
}
inline ::aapt::pb::TypeId* Type::_internal_mutable_type_id() {
  
  if (_impl_.type_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::TypeId>(GetArenaForAllocation());
    _impl_.type_id_ = p;
  }
  return _impl_.type_id_;
}
inline ::aapt::pb::TypeId* Type::mutable_type_id() {
  ::aapt::pb::TypeId* _msg = _internal_mutable_type_id();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.type_id)
  return _msg;
}
inline void Type::set_allocated_type_id(::aapt::pb::TypeId* type_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.type_id_;
  }
  if (type_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type_id);
    if (message_arena != submessage_arena) {
      type_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.type_id_ = type_id;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.type_id)
}

// string name = 2;
inline void Type::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Type::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Type.name)
}
inline std::string* Type::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.name)
  return _s;
}
inline const std::string& Type::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Type::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Type::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Type.name)
  return _impl_.name_.Release();
}
inline void Type::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.name)
}

// repeated .aapt.pb.Entry entry = 3;
inline int Type::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int Type::entry_size() const {
  return _internal_entry_size();
}
inline void Type::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::aapt::pb::Entry* Type::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >*
Type::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Type.entry)
  return &_impl_.entry_;
}
inline const ::aapt::pb::Entry& Type::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::aapt::pb::Entry& Type::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.entry)
  return _internal_entry(index);
}
inline ::aapt::pb::Entry* Type::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::aapt::pb::Entry* Type::add_entry() {
  ::aapt::pb::Entry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:aapt.pb.Type.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >&
Type::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Type.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// Visibility

// .aapt.pb.Visibility.Level level = 1;
inline void Visibility::clear_level() {
  _impl_.level_ = 0;
}
inline ::aapt::pb::Visibility_Level Visibility::_internal_level() const {
  return static_cast< ::aapt::pb::Visibility_Level >(_impl_.level_);
}
inline ::aapt::pb::Visibility_Level Visibility::level() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.level)
  return _internal_level();
}
inline void Visibility::_internal_set_level(::aapt::pb::Visibility_Level value) {
  
  _impl_.level_ = value;
}
inline void Visibility::set_level(::aapt::pb::Visibility_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Visibility.level)
}

// .aapt.pb.Source source = 2;
inline bool Visibility::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Visibility::has_source() const {
  return _internal_has_source();
}
inline void Visibility::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Visibility::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Visibility::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.source)
  return _internal_source();
}
inline void Visibility::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Visibility.source)
}
inline ::aapt::pb::Source* Visibility::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Visibility::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Visibility.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Visibility::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Visibility::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Visibility.source)
  return _msg;
}
inline void Visibility::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Visibility.source)
}

// string comment = 3;
inline void Visibility::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Visibility::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Visibility::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Visibility.comment)
}
inline std::string* Visibility::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Visibility.comment)
  return _s;
}
inline const std::string& Visibility::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Visibility::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Visibility::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Visibility::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Visibility.comment)
  return _impl_.comment_.Release();
}
inline void Visibility::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Visibility.comment)
}

// -------------------------------------------------------------------

// AllowNew

// .aapt.pb.Source source = 1;
inline bool AllowNew::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool AllowNew::has_source() const {
  return _internal_has_source();
}
inline void AllowNew::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& AllowNew::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& AllowNew::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.AllowNew.source)
  return _internal_source();
}
inline void AllowNew::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.AllowNew.source)
}
inline ::aapt::pb::Source* AllowNew::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* AllowNew::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.AllowNew.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* AllowNew::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* AllowNew::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.AllowNew.source)
  return _msg;
}
inline void AllowNew::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.AllowNew.source)
}

// string comment = 2;
inline void AllowNew::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& AllowNew::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.AllowNew.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowNew::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.AllowNew.comment)
}
inline std::string* AllowNew::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.AllowNew.comment)
  return _s;
}
inline const std::string& AllowNew::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void AllowNew::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* AllowNew::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* AllowNew::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.AllowNew.comment)
  return _impl_.comment_.Release();
}
inline void AllowNew::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.AllowNew.comment)
}

// -------------------------------------------------------------------

// Overlayable

// string name = 1;
inline void Overlayable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Overlayable::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Overlayable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Overlayable.name)
}
inline std::string* Overlayable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.name)
  return _s;
}
inline const std::string& Overlayable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Overlayable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Overlayable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Overlayable::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.name)
  return _impl_.name_.Release();
}
inline void Overlayable::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.name)
}

// .aapt.pb.Source source = 2;
inline bool Overlayable::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Overlayable::has_source() const {
  return _internal_has_source();
}
inline void Overlayable::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Overlayable::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Overlayable::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.source)
  return _internal_source();
}
inline void Overlayable::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Overlayable.source)
}
inline ::aapt::pb::Source* Overlayable::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Overlayable::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Overlayable::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Overlayable::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.source)
  return _msg;
}
inline void Overlayable::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.source)
}

// string actor = 3;
inline void Overlayable::clear_actor() {
  _impl_.actor_.ClearToEmpty();
}
inline const std::string& Overlayable::actor() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.actor)
  return _internal_actor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Overlayable::set_actor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.actor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Overlayable.actor)
}
inline std::string* Overlayable::mutable_actor() {
  std::string* _s = _internal_mutable_actor();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.actor)
  return _s;
}
inline const std::string& Overlayable::_internal_actor() const {
  return _impl_.actor_.Get();
}
inline void Overlayable::_internal_set_actor(const std::string& value) {
  
  _impl_.actor_.Set(value, GetArenaForAllocation());
}
inline std::string* Overlayable::_internal_mutable_actor() {
  
  return _impl_.actor_.Mutable(GetArenaForAllocation());
}
inline std::string* Overlayable::release_actor() {
  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.actor)
  return _impl_.actor_.Release();
}
inline void Overlayable::set_allocated_actor(std::string* actor) {
  _impl_.actor_.SetAllocated(actor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.actor_.IsDefault()) {
    _impl_.actor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.actor)
}

// -------------------------------------------------------------------

// OverlayableItem

// .aapt.pb.Source source = 1;
inline bool OverlayableItem::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool OverlayableItem::has_source() const {
  return _internal_has_source();
}
inline void OverlayableItem::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& OverlayableItem::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& OverlayableItem::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.source)
  return _internal_source();
}
inline void OverlayableItem::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.OverlayableItem.source)
}
inline ::aapt::pb::Source* OverlayableItem::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* OverlayableItem::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.OverlayableItem.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* OverlayableItem::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* OverlayableItem::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.OverlayableItem.source)
  return _msg;
}
inline void OverlayableItem::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.OverlayableItem.source)
}

// string comment = 2;
inline void OverlayableItem::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& OverlayableItem::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlayableItem::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.comment)
}
inline std::string* OverlayableItem::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.OverlayableItem.comment)
  return _s;
}
inline const std::string& OverlayableItem::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void OverlayableItem::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlayableItem::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* OverlayableItem::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.OverlayableItem.comment)
  return _impl_.comment_.Release();
}
inline void OverlayableItem::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.OverlayableItem.comment)
}

// repeated .aapt.pb.OverlayableItem.Policy policy = 3;
inline int OverlayableItem::_internal_policy_size() const {
  return _impl_.policy_.size();
}
inline int OverlayableItem::policy_size() const {
  return _internal_policy_size();
}
inline void OverlayableItem::clear_policy() {
  _impl_.policy_.Clear();
}
inline ::aapt::pb::OverlayableItem_Policy OverlayableItem::_internal_policy(int index) const {
  return static_cast< ::aapt::pb::OverlayableItem_Policy >(_impl_.policy_.Get(index));
}
inline ::aapt::pb::OverlayableItem_Policy OverlayableItem::policy(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.policy)
  return _internal_policy(index);
}
inline void OverlayableItem::set_policy(int index, ::aapt::pb::OverlayableItem_Policy value) {
  _impl_.policy_.Set(index, value);
  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.policy)
}
inline void OverlayableItem::_internal_add_policy(::aapt::pb::OverlayableItem_Policy value) {
  _impl_.policy_.Add(value);
}
inline void OverlayableItem::add_policy(::aapt::pb::OverlayableItem_Policy value) {
  _internal_add_policy(value);
  // @@protoc_insertion_point(field_add:aapt.pb.OverlayableItem.policy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
OverlayableItem::policy() const {
  // @@protoc_insertion_point(field_list:aapt.pb.OverlayableItem.policy)
  return _impl_.policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OverlayableItem::_internal_mutable_policy() {
  return &_impl_.policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OverlayableItem::mutable_policy() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.OverlayableItem.policy)
  return _internal_mutable_policy();
}

// uint32 overlayable_idx = 4;
inline void OverlayableItem::clear_overlayable_idx() {
  _impl_.overlayable_idx_ = 0u;
}
inline ::uint32_t OverlayableItem::_internal_overlayable_idx() const {
  return _impl_.overlayable_idx_;
}
inline ::uint32_t OverlayableItem::overlayable_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.overlayable_idx)
  return _internal_overlayable_idx();
}
inline void OverlayableItem::_internal_set_overlayable_idx(::uint32_t value) {
  
  _impl_.overlayable_idx_ = value;
}
inline void OverlayableItem::set_overlayable_idx(::uint32_t value) {
  _internal_set_overlayable_idx(value);
  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.overlayable_idx)
}

// -------------------------------------------------------------------

// EntryId

// uint32 id = 1;
inline void EntryId::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t EntryId::_internal_id() const {
  return _impl_.id_;
}
inline ::uint32_t EntryId::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.EntryId.id)
  return _internal_id();
}
inline void EntryId::_internal_set_id(::uint32_t value) {
  
  _impl_.id_ = value;
}
inline void EntryId::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aapt.pb.EntryId.id)
}

// -------------------------------------------------------------------

// Entry

// .aapt.pb.EntryId entry_id = 1;
inline bool Entry::_internal_has_entry_id() const {
  return this != internal_default_instance() && _impl_.entry_id_ != nullptr;
}
inline bool Entry::has_entry_id() const {
  return _internal_has_entry_id();
}
inline void Entry::clear_entry_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.entry_id_ != nullptr) {
    delete _impl_.entry_id_;
  }
  _impl_.entry_id_ = nullptr;
}
inline const ::aapt::pb::EntryId& Entry::_internal_entry_id() const {
  const ::aapt::pb::EntryId* p = _impl_.entry_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::EntryId&>(
      ::aapt::pb::_EntryId_default_instance_);
}
inline const ::aapt::pb::EntryId& Entry::entry_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.entry_id)
  return _internal_entry_id();
}
inline void Entry::unsafe_arena_set_allocated_entry_id(
    ::aapt::pb::EntryId* entry_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entry_id_);
  }
  _impl_.entry_id_ = entry_id;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.entry_id)
}
inline ::aapt::pb::EntryId* Entry::release_entry_id() {
  
  ::aapt::pb::EntryId* temp = _impl_.entry_id_;
  _impl_.entry_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::EntryId* Entry::unsafe_arena_release_entry_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.entry_id)
  
  ::aapt::pb::EntryId* temp = _impl_.entry_id_;
  _impl_.entry_id_ = nullptr;
  return temp;
}
inline ::aapt::pb::EntryId* Entry::_internal_mutable_entry_id() {
  
  if (_impl_.entry_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::EntryId>(GetArenaForAllocation());
    _impl_.entry_id_ = p;
  }
  return _impl_.entry_id_;
}
inline ::aapt::pb::EntryId* Entry::mutable_entry_id() {
  ::aapt::pb::EntryId* _msg = _internal_mutable_entry_id();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.entry_id)
  return _msg;
}
inline void Entry::set_allocated_entry_id(::aapt::pb::EntryId* entry_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.entry_id_;
  }
  if (entry_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entry_id);
    if (message_arena != submessage_arena) {
      entry_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entry_id_ = entry_id;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.entry_id)
}

// string name = 2;
inline void Entry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Entry::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.name)
}
inline std::string* Entry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.name)
  return _s;
}
inline const std::string& Entry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Entry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Entry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Entry::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.name)
  return _impl_.name_.Release();
}
inline void Entry::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.name)
}

// .aapt.pb.Visibility visibility = 3;
inline bool Entry::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Entry::has_visibility() const {
  return _internal_has_visibility();
}
inline void Entry::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::aapt::pb::Visibility& Entry::_internal_visibility() const {
  const ::aapt::pb::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Visibility&>(
      ::aapt::pb::_Visibility_default_instance_);
}
inline const ::aapt::pb::Visibility& Entry::visibility() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.visibility)
  return _internal_visibility();
}
inline void Entry::unsafe_arena_set_allocated_visibility(
    ::aapt::pb::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.visibility)
}
inline ::aapt::pb::Visibility* Entry::release_visibility() {
  
  ::aapt::pb::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Visibility* Entry::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.visibility)
  
  ::aapt::pb::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::aapt::pb::Visibility* Entry::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::aapt::pb::Visibility* Entry::mutable_visibility() {
  ::aapt::pb::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.visibility)
  return _msg;
}
inline void Entry::set_allocated_visibility(::aapt::pb::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.visibility)
}

// .aapt.pb.AllowNew allow_new = 4;
inline bool Entry::_internal_has_allow_new() const {
  return this != internal_default_instance() && _impl_.allow_new_ != nullptr;
}
inline bool Entry::has_allow_new() const {
  return _internal_has_allow_new();
}
inline void Entry::clear_allow_new() {
  if (GetArenaForAllocation() == nullptr && _impl_.allow_new_ != nullptr) {
    delete _impl_.allow_new_;
  }
  _impl_.allow_new_ = nullptr;
}
inline const ::aapt::pb::AllowNew& Entry::_internal_allow_new() const {
  const ::aapt::pb::AllowNew* p = _impl_.allow_new_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::AllowNew&>(
      ::aapt::pb::_AllowNew_default_instance_);
}
inline const ::aapt::pb::AllowNew& Entry::allow_new() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.allow_new)
  return _internal_allow_new();
}
inline void Entry::unsafe_arena_set_allocated_allow_new(
    ::aapt::pb::AllowNew* allow_new) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_new_);
  }
  _impl_.allow_new_ = allow_new;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.allow_new)
}
inline ::aapt::pb::AllowNew* Entry::release_allow_new() {
  
  ::aapt::pb::AllowNew* temp = _impl_.allow_new_;
  _impl_.allow_new_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::AllowNew* Entry::unsafe_arena_release_allow_new() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.allow_new)
  
  ::aapt::pb::AllowNew* temp = _impl_.allow_new_;
  _impl_.allow_new_ = nullptr;
  return temp;
}
inline ::aapt::pb::AllowNew* Entry::_internal_mutable_allow_new() {
  
  if (_impl_.allow_new_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::AllowNew>(GetArenaForAllocation());
    _impl_.allow_new_ = p;
  }
  return _impl_.allow_new_;
}
inline ::aapt::pb::AllowNew* Entry::mutable_allow_new() {
  ::aapt::pb::AllowNew* _msg = _internal_mutable_allow_new();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.allow_new)
  return _msg;
}
inline void Entry::set_allocated_allow_new(::aapt::pb::AllowNew* allow_new) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allow_new_;
  }
  if (allow_new) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_new);
    if (message_arena != submessage_arena) {
      allow_new = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allow_new, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.allow_new_ = allow_new;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.allow_new)
}

// .aapt.pb.OverlayableItem overlayable_item = 5;
inline bool Entry::_internal_has_overlayable_item() const {
  return this != internal_default_instance() && _impl_.overlayable_item_ != nullptr;
}
inline bool Entry::has_overlayable_item() const {
  return _internal_has_overlayable_item();
}
inline void Entry::clear_overlayable_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.overlayable_item_ != nullptr) {
    delete _impl_.overlayable_item_;
  }
  _impl_.overlayable_item_ = nullptr;
}
inline const ::aapt::pb::OverlayableItem& Entry::_internal_overlayable_item() const {
  const ::aapt::pb::OverlayableItem* p = _impl_.overlayable_item_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::OverlayableItem&>(
      ::aapt::pb::_OverlayableItem_default_instance_);
}
inline const ::aapt::pb::OverlayableItem& Entry::overlayable_item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.overlayable_item)
  return _internal_overlayable_item();
}
inline void Entry::unsafe_arena_set_allocated_overlayable_item(
    ::aapt::pb::OverlayableItem* overlayable_item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overlayable_item_);
  }
  _impl_.overlayable_item_ = overlayable_item;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.overlayable_item)
}
inline ::aapt::pb::OverlayableItem* Entry::release_overlayable_item() {
  
  ::aapt::pb::OverlayableItem* temp = _impl_.overlayable_item_;
  _impl_.overlayable_item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::OverlayableItem* Entry::unsafe_arena_release_overlayable_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.overlayable_item)
  
  ::aapt::pb::OverlayableItem* temp = _impl_.overlayable_item_;
  _impl_.overlayable_item_ = nullptr;
  return temp;
}
inline ::aapt::pb::OverlayableItem* Entry::_internal_mutable_overlayable_item() {
  
  if (_impl_.overlayable_item_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::OverlayableItem>(GetArenaForAllocation());
    _impl_.overlayable_item_ = p;
  }
  return _impl_.overlayable_item_;
}
inline ::aapt::pb::OverlayableItem* Entry::mutable_overlayable_item() {
  ::aapt::pb::OverlayableItem* _msg = _internal_mutable_overlayable_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.overlayable_item)
  return _msg;
}
inline void Entry::set_allocated_overlayable_item(::aapt::pb::OverlayableItem* overlayable_item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.overlayable_item_;
  }
  if (overlayable_item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overlayable_item);
    if (message_arena != submessage_arena) {
      overlayable_item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overlayable_item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.overlayable_item_ = overlayable_item;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.overlayable_item)
}

// repeated .aapt.pb.ConfigValue config_value = 6;
inline int Entry::_internal_config_value_size() const {
  return _impl_.config_value_.size();
}
inline int Entry::config_value_size() const {
  return _internal_config_value_size();
}
inline void Entry::clear_config_value() {
  _impl_.config_value_.Clear();
}
inline ::aapt::pb::ConfigValue* Entry::mutable_config_value(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.config_value)
  return _impl_.config_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >*
Entry::mutable_config_value() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Entry.config_value)
  return &_impl_.config_value_;
}
inline const ::aapt::pb::ConfigValue& Entry::_internal_config_value(int index) const {
  return _impl_.config_value_.Get(index);
}
inline const ::aapt::pb::ConfigValue& Entry::config_value(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.config_value)
  return _internal_config_value(index);
}
inline ::aapt::pb::ConfigValue* Entry::_internal_add_config_value() {
  return _impl_.config_value_.Add();
}
inline ::aapt::pb::ConfigValue* Entry::add_config_value() {
  ::aapt::pb::ConfigValue* _add = _internal_add_config_value();
  // @@protoc_insertion_point(field_add:aapt.pb.Entry.config_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >&
Entry::config_value() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Entry.config_value)
  return _impl_.config_value_;
}

// -------------------------------------------------------------------

// ConfigValue

// .aapt.pb.Configuration config = 1;
inline bool ConfigValue::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool ConfigValue::has_config() const {
  return _internal_has_config();
}
inline const ::aapt::pb::Configuration& ConfigValue::_internal_config() const {
  const ::aapt::pb::Configuration* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Configuration&>(
      ::aapt::pb::_Configuration_default_instance_);
}
inline const ::aapt::pb::Configuration& ConfigValue::config() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.config)
  return _internal_config();
}
inline void ConfigValue::unsafe_arena_set_allocated_config(
    ::aapt::pb::Configuration* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ConfigValue.config)
}
inline ::aapt::pb::Configuration* ConfigValue::release_config() {
  
  ::aapt::pb::Configuration* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Configuration* ConfigValue::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.config)
  
  ::aapt::pb::Configuration* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::aapt::pb::Configuration* ConfigValue::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Configuration>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::aapt::pb::Configuration* ConfigValue::mutable_config() {
  ::aapt::pb::Configuration* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.config)
  return _msg;
}
inline void ConfigValue::set_allocated_config(::aapt::pb::Configuration* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.config)
}

// .aapt.pb.Value value = 2;
inline bool ConfigValue::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool ConfigValue::has_value() const {
  return _internal_has_value();
}
inline void ConfigValue::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::aapt::pb::Value& ConfigValue::_internal_value() const {
  const ::aapt::pb::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Value&>(
      ::aapt::pb::_Value_default_instance_);
}
inline const ::aapt::pb::Value& ConfigValue::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.value)
  return _internal_value();
}
inline void ConfigValue::unsafe_arena_set_allocated_value(
    ::aapt::pb::Value* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ConfigValue.value)
}
inline ::aapt::pb::Value* ConfigValue::release_value() {
  
  ::aapt::pb::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Value* ConfigValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.value)
  
  ::aapt::pb::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::aapt::pb::Value* ConfigValue::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Value>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::aapt::pb::Value* ConfigValue::mutable_value() {
  ::aapt::pb::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.value)
  return _msg;
}
inline void ConfigValue::set_allocated_value(::aapt::pb::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.value)
}

// -------------------------------------------------------------------

// Value

// .aapt.pb.Source source = 1;
inline bool Value::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Value::has_source() const {
  return _internal_has_source();
}
inline void Value::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Value::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Value::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.source)
  return _internal_source();
}
inline void Value::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.source)
}
inline ::aapt::pb::Source* Value::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Value::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Value::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Value::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.source)
  return _msg;
}
inline void Value::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.source)
}

// string comment = 2;
inline void Value::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Value::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Value.comment)
}
inline std::string* Value::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.comment)
  return _s;
}
inline const std::string& Value::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Value::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Value::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.comment)
  return _impl_.comment_.Release();
}
inline void Value::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.comment)
}

// bool weak = 3;
inline void Value::clear_weak() {
  _impl_.weak_ = false;
}
inline bool Value::_internal_weak() const {
  return _impl_.weak_;
}
inline bool Value::weak() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.weak)
  return _internal_weak();
}
inline void Value::_internal_set_weak(bool value) {
  
  _impl_.weak_ = value;
}
inline void Value::set_weak(bool value) {
  _internal_set_weak(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Value.weak)
}

// .aapt.pb.Item item = 4;
inline bool Value::_internal_has_item() const {
  return value_case() == kItem;
}
inline bool Value::has_item() const {
  return _internal_has_item();
}
inline void Value::set_has_item() {
  _impl_._oneof_case_[0] = kItem;
}
inline void Value::clear_item() {
  if (_internal_has_item()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.item_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Item* Value::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.item)
  if (_internal_has_item()) {
    clear_has_value();
    ::aapt::pb::Item* temp = _impl_.value_.item_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Item& Value::_internal_item() const {
  return _internal_has_item()
      ? *_impl_.value_.item_
      : reinterpret_cast< ::aapt::pb::Item&>(::aapt::pb::_Item_default_instance_);
}
inline const ::aapt::pb::Item& Value::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.item)
  return _internal_item();
}
inline ::aapt::pb::Item* Value::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Value.item)
  if (_internal_has_item()) {
    clear_has_value();
    ::aapt::pb::Item* temp = _impl_.value_.item_;
    _impl_.value_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_item(::aapt::pb::Item* item) {
  clear_value();
  if (item) {
    set_has_item();
    _impl_.value_.item_ = item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.item)
}
inline ::aapt::pb::Item* Value::_internal_mutable_item() {
  if (!_internal_has_item()) {
    clear_value();
    set_has_item();
    _impl_.value_.item_ = CreateMaybeMessage< ::aapt::pb::Item >(GetArenaForAllocation());
  }
  return _impl_.value_.item_;
}
inline ::aapt::pb::Item* Value::mutable_item() {
  ::aapt::pb::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.item)
  return _msg;
}

// .aapt.pb.CompoundValue compound_value = 5;
inline bool Value::_internal_has_compound_value() const {
  return value_case() == kCompoundValue;
}
inline bool Value::has_compound_value() const {
  return _internal_has_compound_value();
}
inline void Value::set_has_compound_value() {
  _impl_._oneof_case_[0] = kCompoundValue;
}
inline void Value::clear_compound_value() {
  if (_internal_has_compound_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.compound_value_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::CompoundValue* Value::release_compound_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.compound_value)
  if (_internal_has_compound_value()) {
    clear_has_value();
    ::aapt::pb::CompoundValue* temp = _impl_.value_.compound_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.compound_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::CompoundValue& Value::_internal_compound_value() const {
  return _internal_has_compound_value()
      ? *_impl_.value_.compound_value_
      : reinterpret_cast< ::aapt::pb::CompoundValue&>(::aapt::pb::_CompoundValue_default_instance_);
}
inline const ::aapt::pb::CompoundValue& Value::compound_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.compound_value)
  return _internal_compound_value();
}
inline ::aapt::pb::CompoundValue* Value::unsafe_arena_release_compound_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Value.compound_value)
  if (_internal_has_compound_value()) {
    clear_has_value();
    ::aapt::pb::CompoundValue* temp = _impl_.value_.compound_value_;
    _impl_.value_.compound_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
  clear_value();
  if (compound_value) {
    set_has_compound_value();
    _impl_.value_.compound_value_ = compound_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.compound_value)
}
inline ::aapt::pb::CompoundValue* Value::_internal_mutable_compound_value() {
  if (!_internal_has_compound_value()) {
    clear_value();
    set_has_compound_value();
    _impl_.value_.compound_value_ = CreateMaybeMessage< ::aapt::pb::CompoundValue >(GetArenaForAllocation());
  }
  return _impl_.value_.compound_value_;
}
inline ::aapt::pb::CompoundValue* Value::mutable_compound_value() {
  ::aapt::pb::CompoundValue* _msg = _internal_mutable_compound_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.compound_value)
  return _msg;
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Item

// .aapt.pb.Reference ref = 1;
inline bool Item::_internal_has_ref() const {
  return value_case() == kRef;
}
inline bool Item::has_ref() const {
  return _internal_has_ref();
}
inline void Item::set_has_ref() {
  _impl_._oneof_case_[0] = kRef;
}
inline void Item::clear_ref() {
  if (_internal_has_ref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ref_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Reference* Item::release_ref() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.ref)
  if (_internal_has_ref()) {
    clear_has_value();
    ::aapt::pb::Reference* temp = _impl_.value_.ref_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Reference& Item::_internal_ref() const {
  return _internal_has_ref()
      ? *_impl_.value_.ref_
      : reinterpret_cast< ::aapt::pb::Reference&>(::aapt::pb::_Reference_default_instance_);
}
inline const ::aapt::pb::Reference& Item::ref() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.ref)
  return _internal_ref();
}
inline ::aapt::pb::Reference* Item::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.ref)
  if (_internal_has_ref()) {
    clear_has_value();
    ::aapt::pb::Reference* temp = _impl_.value_.ref_;
    _impl_.value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_ref(::aapt::pb::Reference* ref) {
  clear_value();
  if (ref) {
    set_has_ref();
    _impl_.value_.ref_ = ref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.ref)
}
inline ::aapt::pb::Reference* Item::_internal_mutable_ref() {
  if (!_internal_has_ref()) {
    clear_value();
    set_has_ref();
    _impl_.value_.ref_ = CreateMaybeMessage< ::aapt::pb::Reference >(GetArenaForAllocation());
  }
  return _impl_.value_.ref_;
}
inline ::aapt::pb::Reference* Item::mutable_ref() {
  ::aapt::pb::Reference* _msg = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.ref)
  return _msg;
}

// .aapt.pb.String str = 2;
inline bool Item::_internal_has_str() const {
  return value_case() == kStr;
}
inline bool Item::has_str() const {
  return _internal_has_str();
}
inline void Item::set_has_str() {
  _impl_._oneof_case_[0] = kStr;
}
inline void Item::clear_str() {
  if (_internal_has_str()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.str_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::String* Item::release_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.str)
  if (_internal_has_str()) {
    clear_has_value();
    ::aapt::pb::String* temp = _impl_.value_.str_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::String& Item::_internal_str() const {
  return _internal_has_str()
      ? *_impl_.value_.str_
      : reinterpret_cast< ::aapt::pb::String&>(::aapt::pb::_String_default_instance_);
}
inline const ::aapt::pb::String& Item::str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.str)
  return _internal_str();
}
inline ::aapt::pb::String* Item::unsafe_arena_release_str() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.str)
  if (_internal_has_str()) {
    clear_has_value();
    ::aapt::pb::String* temp = _impl_.value_.str_;
    _impl_.value_.str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_str(::aapt::pb::String* str) {
  clear_value();
  if (str) {
    set_has_str();
    _impl_.value_.str_ = str;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.str)
}
inline ::aapt::pb::String* Item::_internal_mutable_str() {
  if (!_internal_has_str()) {
    clear_value();
    set_has_str();
    _impl_.value_.str_ = CreateMaybeMessage< ::aapt::pb::String >(GetArenaForAllocation());
  }
  return _impl_.value_.str_;
}
inline ::aapt::pb::String* Item::mutable_str() {
  ::aapt::pb::String* _msg = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.str)
  return _msg;
}

// .aapt.pb.RawString raw_str = 3;
inline bool Item::_internal_has_raw_str() const {
  return value_case() == kRawStr;
}
inline bool Item::has_raw_str() const {
  return _internal_has_raw_str();
}
inline void Item::set_has_raw_str() {
  _impl_._oneof_case_[0] = kRawStr;
}
inline void Item::clear_raw_str() {
  if (_internal_has_raw_str()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.raw_str_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::RawString* Item::release_raw_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.raw_str)
  if (_internal_has_raw_str()) {
    clear_has_value();
    ::aapt::pb::RawString* temp = _impl_.value_.raw_str_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.raw_str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::RawString& Item::_internal_raw_str() const {
  return _internal_has_raw_str()
      ? *_impl_.value_.raw_str_
      : reinterpret_cast< ::aapt::pb::RawString&>(::aapt::pb::_RawString_default_instance_);
}
inline const ::aapt::pb::RawString& Item::raw_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.raw_str)
  return _internal_raw_str();
}
inline ::aapt::pb::RawString* Item::unsafe_arena_release_raw_str() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.raw_str)
  if (_internal_has_raw_str()) {
    clear_has_value();
    ::aapt::pb::RawString* temp = _impl_.value_.raw_str_;
    _impl_.value_.raw_str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
  clear_value();
  if (raw_str) {
    set_has_raw_str();
    _impl_.value_.raw_str_ = raw_str;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.raw_str)
}
inline ::aapt::pb::RawString* Item::_internal_mutable_raw_str() {
  if (!_internal_has_raw_str()) {
    clear_value();
    set_has_raw_str();
    _impl_.value_.raw_str_ = CreateMaybeMessage< ::aapt::pb::RawString >(GetArenaForAllocation());
  }
  return _impl_.value_.raw_str_;
}
inline ::aapt::pb::RawString* Item::mutable_raw_str() {
  ::aapt::pb::RawString* _msg = _internal_mutable_raw_str();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.raw_str)
  return _msg;
}

// .aapt.pb.StyledString styled_str = 4;
inline bool Item::_internal_has_styled_str() const {
  return value_case() == kStyledStr;
}
inline bool Item::has_styled_str() const {
  return _internal_has_styled_str();
}
inline void Item::set_has_styled_str() {
  _impl_._oneof_case_[0] = kStyledStr;
}
inline void Item::clear_styled_str() {
  if (_internal_has_styled_str()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.styled_str_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::StyledString* Item::release_styled_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.styled_str)
  if (_internal_has_styled_str()) {
    clear_has_value();
    ::aapt::pb::StyledString* temp = _impl_.value_.styled_str_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.styled_str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::StyledString& Item::_internal_styled_str() const {
  return _internal_has_styled_str()
      ? *_impl_.value_.styled_str_
      : reinterpret_cast< ::aapt::pb::StyledString&>(::aapt::pb::_StyledString_default_instance_);
}
inline const ::aapt::pb::StyledString& Item::styled_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.styled_str)
  return _internal_styled_str();
}
inline ::aapt::pb::StyledString* Item::unsafe_arena_release_styled_str() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.styled_str)
  if (_internal_has_styled_str()) {
    clear_has_value();
    ::aapt::pb::StyledString* temp = _impl_.value_.styled_str_;
    _impl_.value_.styled_str_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_styled_str(::aapt::pb::StyledString* styled_str) {
  clear_value();
  if (styled_str) {
    set_has_styled_str();
    _impl_.value_.styled_str_ = styled_str;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.styled_str)
}
inline ::aapt::pb::StyledString* Item::_internal_mutable_styled_str() {
  if (!_internal_has_styled_str()) {
    clear_value();
    set_has_styled_str();
    _impl_.value_.styled_str_ = CreateMaybeMessage< ::aapt::pb::StyledString >(GetArenaForAllocation());
  }
  return _impl_.value_.styled_str_;
}
inline ::aapt::pb::StyledString* Item::mutable_styled_str() {
  ::aapt::pb::StyledString* _msg = _internal_mutable_styled_str();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.styled_str)
  return _msg;
}

// .aapt.pb.FileReference file = 5;
inline bool Item::_internal_has_file() const {
  return value_case() == kFile;
}
inline bool Item::has_file() const {
  return _internal_has_file();
}
inline void Item::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void Item::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.file_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::FileReference* Item::release_file() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.file)
  if (_internal_has_file()) {
    clear_has_value();
    ::aapt::pb::FileReference* temp = _impl_.value_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::FileReference& Item::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.value_.file_
      : reinterpret_cast< ::aapt::pb::FileReference&>(::aapt::pb::_FileReference_default_instance_);
}
inline const ::aapt::pb::FileReference& Item::file() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.file)
  return _internal_file();
}
inline ::aapt::pb::FileReference* Item::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.file)
  if (_internal_has_file()) {
    clear_has_value();
    ::aapt::pb::FileReference* temp = _impl_.value_.file_;
    _impl_.value_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_file(::aapt::pb::FileReference* file) {
  clear_value();
  if (file) {
    set_has_file();
    _impl_.value_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.file)
}
inline ::aapt::pb::FileReference* Item::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_value();
    set_has_file();
    _impl_.value_.file_ = CreateMaybeMessage< ::aapt::pb::FileReference >(GetArenaForAllocation());
  }
  return _impl_.value_.file_;
}
inline ::aapt::pb::FileReference* Item::mutable_file() {
  ::aapt::pb::FileReference* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.file)
  return _msg;
}

// .aapt.pb.Id id = 6;
inline bool Item::_internal_has_id() const {
  return value_case() == kId;
}
inline bool Item::has_id() const {
  return _internal_has_id();
}
inline void Item::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void Item::clear_id() {
  if (_internal_has_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.id_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Id* Item::release_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.id)
  if (_internal_has_id()) {
    clear_has_value();
    ::aapt::pb::Id* temp = _impl_.value_.id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Id& Item::_internal_id() const {
  return _internal_has_id()
      ? *_impl_.value_.id_
      : reinterpret_cast< ::aapt::pb::Id&>(::aapt::pb::_Id_default_instance_);
}
inline const ::aapt::pb::Id& Item::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.id)
  return _internal_id();
}
inline ::aapt::pb::Id* Item::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.id)
  if (_internal_has_id()) {
    clear_has_value();
    ::aapt::pb::Id* temp = _impl_.value_.id_;
    _impl_.value_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_id(::aapt::pb::Id* id) {
  clear_value();
  if (id) {
    set_has_id();
    _impl_.value_.id_ = id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.id)
}
inline ::aapt::pb::Id* Item::_internal_mutable_id() {
  if (!_internal_has_id()) {
    clear_value();
    set_has_id();
    _impl_.value_.id_ = CreateMaybeMessage< ::aapt::pb::Id >(GetArenaForAllocation());
  }
  return _impl_.value_.id_;
}
inline ::aapt::pb::Id* Item::mutable_id() {
  ::aapt::pb::Id* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.id)
  return _msg;
}

// .aapt.pb.Primitive prim = 7;
inline bool Item::_internal_has_prim() const {
  return value_case() == kPrim;
}
inline bool Item::has_prim() const {
  return _internal_has_prim();
}
inline void Item::set_has_prim() {
  _impl_._oneof_case_[0] = kPrim;
}
inline void Item::clear_prim() {
  if (_internal_has_prim()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.prim_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Primitive* Item::release_prim() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.prim)
  if (_internal_has_prim()) {
    clear_has_value();
    ::aapt::pb::Primitive* temp = _impl_.value_.prim_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.prim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Primitive& Item::_internal_prim() const {
  return _internal_has_prim()
      ? *_impl_.value_.prim_
      : reinterpret_cast< ::aapt::pb::Primitive&>(::aapt::pb::_Primitive_default_instance_);
}
inline const ::aapt::pb::Primitive& Item::prim() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.prim)
  return _internal_prim();
}
inline ::aapt::pb::Primitive* Item::unsafe_arena_release_prim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.prim)
  if (_internal_has_prim()) {
    clear_has_value();
    ::aapt::pb::Primitive* temp = _impl_.value_.prim_;
    _impl_.value_.prim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_prim(::aapt::pb::Primitive* prim) {
  clear_value();
  if (prim) {
    set_has_prim();
    _impl_.value_.prim_ = prim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.prim)
}
inline ::aapt::pb::Primitive* Item::_internal_mutable_prim() {
  if (!_internal_has_prim()) {
    clear_value();
    set_has_prim();
    _impl_.value_.prim_ = CreateMaybeMessage< ::aapt::pb::Primitive >(GetArenaForAllocation());
  }
  return _impl_.value_.prim_;
}
inline ::aapt::pb::Primitive* Item::mutable_prim() {
  ::aapt::pb::Primitive* _msg = _internal_mutable_prim();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.prim)
  return _msg;
}

inline bool Item::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Item::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Item::ValueCase Item::value_case() const {
  return Item::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompoundValue

// .aapt.pb.Attribute attr = 1;
inline bool CompoundValue::_internal_has_attr() const {
  return value_case() == kAttr;
}
inline bool CompoundValue::has_attr() const {
  return _internal_has_attr();
}
inline void CompoundValue::set_has_attr() {
  _impl_._oneof_case_[0] = kAttr;
}
inline void CompoundValue::clear_attr() {
  if (_internal_has_attr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.attr_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Attribute* CompoundValue::release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.attr)
  if (_internal_has_attr()) {
    clear_has_value();
    ::aapt::pb::Attribute* temp = _impl_.value_.attr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.attr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Attribute& CompoundValue::_internal_attr() const {
  return _internal_has_attr()
      ? *_impl_.value_.attr_
      : reinterpret_cast< ::aapt::pb::Attribute&>(::aapt::pb::_Attribute_default_instance_);
}
inline const ::aapt::pb::Attribute& CompoundValue::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.attr)
  return _internal_attr();
}
inline ::aapt::pb::Attribute* CompoundValue::unsafe_arena_release_attr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.attr)
  if (_internal_has_attr()) {
    clear_has_value();
    ::aapt::pb::Attribute* temp = _impl_.value_.attr_;
    _impl_.value_.attr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompoundValue::unsafe_arena_set_allocated_attr(::aapt::pb::Attribute* attr) {
  clear_value();
  if (attr) {
    set_has_attr();
    _impl_.value_.attr_ = attr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.attr)
}
inline ::aapt::pb::Attribute* CompoundValue::_internal_mutable_attr() {
  if (!_internal_has_attr()) {
    clear_value();
    set_has_attr();
    _impl_.value_.attr_ = CreateMaybeMessage< ::aapt::pb::Attribute >(GetArenaForAllocation());
  }
  return _impl_.value_.attr_;
}
inline ::aapt::pb::Attribute* CompoundValue::mutable_attr() {
  ::aapt::pb::Attribute* _msg = _internal_mutable_attr();
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.attr)
  return _msg;
}

// .aapt.pb.Style style = 2;
inline bool CompoundValue::_internal_has_style() const {
  return value_case() == kStyle;
}
inline bool CompoundValue::has_style() const {
  return _internal_has_style();
}
inline void CompoundValue::set_has_style() {
  _impl_._oneof_case_[0] = kStyle;
}
inline void CompoundValue::clear_style() {
  if (_internal_has_style()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.style_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Style* CompoundValue::release_style() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.style)
  if (_internal_has_style()) {
    clear_has_value();
    ::aapt::pb::Style* temp = _impl_.value_.style_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Style& CompoundValue::_internal_style() const {
  return _internal_has_style()
      ? *_impl_.value_.style_
      : reinterpret_cast< ::aapt::pb::Style&>(::aapt::pb::_Style_default_instance_);
}
inline const ::aapt::pb::Style& CompoundValue::style() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.style)
  return _internal_style();
}
inline ::aapt::pb::Style* CompoundValue::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.style)
  if (_internal_has_style()) {
    clear_has_value();
    ::aapt::pb::Style* temp = _impl_.value_.style_;
    _impl_.value_.style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompoundValue::unsafe_arena_set_allocated_style(::aapt::pb::Style* style) {
  clear_value();
  if (style) {
    set_has_style();
    _impl_.value_.style_ = style;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.style)
}
inline ::aapt::pb::Style* CompoundValue::_internal_mutable_style() {
  if (!_internal_has_style()) {
    clear_value();
    set_has_style();
    _impl_.value_.style_ = CreateMaybeMessage< ::aapt::pb::Style >(GetArenaForAllocation());
  }
  return _impl_.value_.style_;
}
inline ::aapt::pb::Style* CompoundValue::mutable_style() {
  ::aapt::pb::Style* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.style)
  return _msg;
}

// .aapt.pb.Styleable styleable = 3;
inline bool CompoundValue::_internal_has_styleable() const {
  return value_case() == kStyleable;
}
inline bool CompoundValue::has_styleable() const {
  return _internal_has_styleable();
}
inline void CompoundValue::set_has_styleable() {
  _impl_._oneof_case_[0] = kStyleable;
}
inline void CompoundValue::clear_styleable() {
  if (_internal_has_styleable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.styleable_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Styleable* CompoundValue::release_styleable() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.styleable)
  if (_internal_has_styleable()) {
    clear_has_value();
    ::aapt::pb::Styleable* temp = _impl_.value_.styleable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.styleable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Styleable& CompoundValue::_internal_styleable() const {
  return _internal_has_styleable()
      ? *_impl_.value_.styleable_
      : reinterpret_cast< ::aapt::pb::Styleable&>(::aapt::pb::_Styleable_default_instance_);
}
inline const ::aapt::pb::Styleable& CompoundValue::styleable() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.styleable)
  return _internal_styleable();
}
inline ::aapt::pb::Styleable* CompoundValue::unsafe_arena_release_styleable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.styleable)
  if (_internal_has_styleable()) {
    clear_has_value();
    ::aapt::pb::Styleable* temp = _impl_.value_.styleable_;
    _impl_.value_.styleable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompoundValue::unsafe_arena_set_allocated_styleable(::aapt::pb::Styleable* styleable) {
  clear_value();
  if (styleable) {
    set_has_styleable();
    _impl_.value_.styleable_ = styleable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.styleable)
}
inline ::aapt::pb::Styleable* CompoundValue::_internal_mutable_styleable() {
  if (!_internal_has_styleable()) {
    clear_value();
    set_has_styleable();
    _impl_.value_.styleable_ = CreateMaybeMessage< ::aapt::pb::Styleable >(GetArenaForAllocation());
  }
  return _impl_.value_.styleable_;
}
inline ::aapt::pb::Styleable* CompoundValue::mutable_styleable() {
  ::aapt::pb::Styleable* _msg = _internal_mutable_styleable();
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.styleable)
  return _msg;
}

// .aapt.pb.Array array = 4;
inline bool CompoundValue::_internal_has_array() const {
  return value_case() == kArray;
}
inline bool CompoundValue::has_array() const {
  return _internal_has_array();
}
inline void CompoundValue::set_has_array() {
  _impl_._oneof_case_[0] = kArray;
}
inline void CompoundValue::clear_array() {
  if (_internal_has_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.array_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Array* CompoundValue::release_array() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.array)
  if (_internal_has_array()) {
    clear_has_value();
    ::aapt::pb::Array* temp = _impl_.value_.array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Array& CompoundValue::_internal_array() const {
  return _internal_has_array()
      ? *_impl_.value_.array_
      : reinterpret_cast< ::aapt::pb::Array&>(::aapt::pb::_Array_default_instance_);
}
inline const ::aapt::pb::Array& CompoundValue::array() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.array)
  return _internal_array();
}
inline ::aapt::pb::Array* CompoundValue::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.array)
  if (_internal_has_array()) {
    clear_has_value();
    ::aapt::pb::Array* temp = _impl_.value_.array_;
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompoundValue::unsafe_arena_set_allocated_array(::aapt::pb::Array* array) {
  clear_value();
  if (array) {
    set_has_array();
    _impl_.value_.array_ = array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.array)
}
inline ::aapt::pb::Array* CompoundValue::_internal_mutable_array() {
  if (!_internal_has_array()) {
    clear_value();
    set_has_array();
    _impl_.value_.array_ = CreateMaybeMessage< ::aapt::pb::Array >(GetArenaForAllocation());
  }
  return _impl_.value_.array_;
}
inline ::aapt::pb::Array* CompoundValue::mutable_array() {
  ::aapt::pb::Array* _msg = _internal_mutable_array();
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.array)
  return _msg;
}

// .aapt.pb.Plural plural = 5;
inline bool CompoundValue::_internal_has_plural() const {
  return value_case() == kPlural;
}
inline bool CompoundValue::has_plural() const {
  return _internal_has_plural();
}
inline void CompoundValue::set_has_plural() {
  _impl_._oneof_case_[0] = kPlural;
}
inline void CompoundValue::clear_plural() {
  if (_internal_has_plural()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.plural_;
    }
    clear_has_value();
  }
}
inline ::aapt::pb::Plural* CompoundValue::release_plural() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.plural)
  if (_internal_has_plural()) {
    clear_has_value();
    ::aapt::pb::Plural* temp = _impl_.value_.plural_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.plural_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Plural& CompoundValue::_internal_plural() const {
  return _internal_has_plural()
      ? *_impl_.value_.plural_
      : reinterpret_cast< ::aapt::pb::Plural&>(::aapt::pb::_Plural_default_instance_);
}
inline const ::aapt::pb::Plural& CompoundValue::plural() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.plural)
  return _internal_plural();
}
inline ::aapt::pb::Plural* CompoundValue::unsafe_arena_release_plural() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.plural)
  if (_internal_has_plural()) {
    clear_has_value();
    ::aapt::pb::Plural* temp = _impl_.value_.plural_;
    _impl_.value_.plural_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompoundValue::unsafe_arena_set_allocated_plural(::aapt::pb::Plural* plural) {
  clear_value();
  if (plural) {
    set_has_plural();
    _impl_.value_.plural_ = plural;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.plural)
}
inline ::aapt::pb::Plural* CompoundValue::_internal_mutable_plural() {
  if (!_internal_has_plural()) {
    clear_value();
    set_has_plural();
    _impl_.value_.plural_ = CreateMaybeMessage< ::aapt::pb::Plural >(GetArenaForAllocation());
  }
  return _impl_.value_.plural_;
}
inline ::aapt::pb::Plural* CompoundValue::mutable_plural() {
  ::aapt::pb::Plural* _msg = _internal_mutable_plural();
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.plural)
  return _msg;
}

inline bool CompoundValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void CompoundValue::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline CompoundValue::ValueCase CompoundValue::value_case() const {
  return CompoundValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Boolean

// bool value = 1;
inline void Boolean::clear_value() {
  _impl_.value_ = false;
}
inline bool Boolean::_internal_value() const {
  return _impl_.value_;
}
inline bool Boolean::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Boolean.value)
  return _internal_value();
}
inline void Boolean::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void Boolean::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Boolean.value)
}

// -------------------------------------------------------------------

// Reference

// .aapt.pb.Reference.Type type = 1;
inline void Reference::clear_type() {
  _impl_.type_ = 0;
}
inline ::aapt::pb::Reference_Type Reference::_internal_type() const {
  return static_cast< ::aapt::pb::Reference_Type >(_impl_.type_);
}
inline ::aapt::pb::Reference_Type Reference::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type)
  return _internal_type();
}
inline void Reference::_internal_set_type(::aapt::pb::Reference_Type value) {
  
  _impl_.type_ = value;
}
inline void Reference::set_type(::aapt::pb::Reference_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type)
}

// uint32 id = 2;
inline void Reference::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t Reference::_internal_id() const {
  return _impl_.id_;
}
inline ::uint32_t Reference::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.id)
  return _internal_id();
}
inline void Reference::_internal_set_id(::uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Reference::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.id)
}

// string name = 3;
inline void Reference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Reference::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.name)
}
inline std::string* Reference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.name)
  return _s;
}
inline const std::string& Reference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Reference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Reference::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Reference.name)
  return _impl_.name_.Release();
}
inline void Reference::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.name)
}

// bool private = 4;
inline void Reference::clear_private_() {
  _impl_.private__ = false;
}
inline bool Reference::_internal_private_() const {
  return _impl_.private__;
}
inline bool Reference::private_() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.private)
  return _internal_private_();
}
inline void Reference::_internal_set_private_(bool value) {
  
  _impl_.private__ = value;
}
inline void Reference::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.private)
}

// .aapt.pb.Boolean is_dynamic = 5;
inline bool Reference::_internal_has_is_dynamic() const {
  return this != internal_default_instance() && _impl_.is_dynamic_ != nullptr;
}
inline bool Reference::has_is_dynamic() const {
  return _internal_has_is_dynamic();
}
inline void Reference::clear_is_dynamic() {
  if (GetArenaForAllocation() == nullptr && _impl_.is_dynamic_ != nullptr) {
    delete _impl_.is_dynamic_;
  }
  _impl_.is_dynamic_ = nullptr;
}
inline const ::aapt::pb::Boolean& Reference::_internal_is_dynamic() const {
  const ::aapt::pb::Boolean* p = _impl_.is_dynamic_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Boolean&>(
      ::aapt::pb::_Boolean_default_instance_);
}
inline const ::aapt::pb::Boolean& Reference::is_dynamic() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.is_dynamic)
  return _internal_is_dynamic();
}
inline void Reference::unsafe_arena_set_allocated_is_dynamic(
    ::aapt::pb::Boolean* is_dynamic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.is_dynamic_);
  }
  _impl_.is_dynamic_ = is_dynamic;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Reference.is_dynamic)
}
inline ::aapt::pb::Boolean* Reference::release_is_dynamic() {
  
  ::aapt::pb::Boolean* temp = _impl_.is_dynamic_;
  _impl_.is_dynamic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Boolean* Reference::unsafe_arena_release_is_dynamic() {
  // @@protoc_insertion_point(field_release:aapt.pb.Reference.is_dynamic)
  
  ::aapt::pb::Boolean* temp = _impl_.is_dynamic_;
  _impl_.is_dynamic_ = nullptr;
  return temp;
}
inline ::aapt::pb::Boolean* Reference::_internal_mutable_is_dynamic() {
  
  if (_impl_.is_dynamic_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Boolean>(GetArenaForAllocation());
    _impl_.is_dynamic_ = p;
  }
  return _impl_.is_dynamic_;
}
inline ::aapt::pb::Boolean* Reference::mutable_is_dynamic() {
  ::aapt::pb::Boolean* _msg = _internal_mutable_is_dynamic();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.is_dynamic)
  return _msg;
}
inline void Reference::set_allocated_is_dynamic(::aapt::pb::Boolean* is_dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.is_dynamic_;
  }
  if (is_dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(is_dynamic);
    if (message_arena != submessage_arena) {
      is_dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, is_dynamic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.is_dynamic_ = is_dynamic;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.is_dynamic)
}

// -------------------------------------------------------------------

// Id

// -------------------------------------------------------------------

// String

// string value = 1;
inline void String::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& String::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.String.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void String::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.String.value)
}
inline std::string* String::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.String.value)
  return _s;
}
inline const std::string& String::_internal_value() const {
  return _impl_.value_.Get();
}
inline void String::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* String::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* String::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.String.value)
  return _impl_.value_.Release();
}
inline void String::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.String.value)
}

// -------------------------------------------------------------------

// RawString

// string value = 1;
inline void RawString::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& RawString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.RawString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RawString::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.RawString.value)
}
inline std::string* RawString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.RawString.value)
  return _s;
}
inline const std::string& RawString::_internal_value() const {
  return _impl_.value_.Get();
}
inline void RawString::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* RawString::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* RawString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.RawString.value)
  return _impl_.value_.Release();
}
inline void RawString::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.RawString.value)
}

// -------------------------------------------------------------------

// StyledString_Span

// string tag = 1;
inline void StyledString_Span::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& StyledString_Span::tag() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StyledString_Span::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.tag)
}
inline std::string* StyledString_Span::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.Span.tag)
  return _s;
}
inline const std::string& StyledString_Span::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void StyledString_Span::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* StyledString_Span::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* StyledString_Span::release_tag() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.Span.tag)
  return _impl_.tag_.Release();
}
inline void StyledString_Span::set_allocated_tag(std::string* tag) {
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.Span.tag)
}

// uint32 first_char = 2;
inline void StyledString_Span::clear_first_char() {
  _impl_.first_char_ = 0u;
}
inline ::uint32_t StyledString_Span::_internal_first_char() const {
  return _impl_.first_char_;
}
inline ::uint32_t StyledString_Span::first_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.first_char)
  return _internal_first_char();
}
inline void StyledString_Span::_internal_set_first_char(::uint32_t value) {
  
  _impl_.first_char_ = value;
}
inline void StyledString_Span::set_first_char(::uint32_t value) {
  _internal_set_first_char(value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.first_char)
}

// uint32 last_char = 3;
inline void StyledString_Span::clear_last_char() {
  _impl_.last_char_ = 0u;
}
inline ::uint32_t StyledString_Span::_internal_last_char() const {
  return _impl_.last_char_;
}
inline ::uint32_t StyledString_Span::last_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.last_char)
  return _internal_last_char();
}
inline void StyledString_Span::_internal_set_last_char(::uint32_t value) {
  
  _impl_.last_char_ = value;
}
inline void StyledString_Span::set_last_char(::uint32_t value) {
  _internal_set_last_char(value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.last_char)
}

// -------------------------------------------------------------------

// StyledString

// string value = 1;
inline void StyledString::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StyledString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StyledString::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.value)
}
inline std::string* StyledString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.value)
  return _s;
}
inline const std::string& StyledString::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StyledString::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StyledString::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StyledString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.value)
  return _impl_.value_.Release();
}
inline void StyledString::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.value)
}

// repeated .aapt.pb.StyledString.Span span = 2;
inline int StyledString::_internal_span_size() const {
  return _impl_.span_.size();
}
inline int StyledString::span_size() const {
  return _internal_span_size();
}
inline void StyledString::clear_span() {
  _impl_.span_.Clear();
}
inline ::aapt::pb::StyledString_Span* StyledString::mutable_span(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.span)
  return _impl_.span_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
StyledString::mutable_span() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.StyledString.span)
  return &_impl_.span_;
}
inline const ::aapt::pb::StyledString_Span& StyledString::_internal_span(int index) const {
  return _impl_.span_.Get(index);
}
inline const ::aapt::pb::StyledString_Span& StyledString::span(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.span)
  return _internal_span(index);
}
inline ::aapt::pb::StyledString_Span* StyledString::_internal_add_span() {
  return _impl_.span_.Add();
}
inline ::aapt::pb::StyledString_Span* StyledString::add_span() {
  ::aapt::pb::StyledString_Span* _add = _internal_add_span();
  // @@protoc_insertion_point(field_add:aapt.pb.StyledString.span)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
StyledString::span() const {
  // @@protoc_insertion_point(field_list:aapt.pb.StyledString.span)
  return _impl_.span_;
}

// -------------------------------------------------------------------

// FileReference

// string path = 1;
inline void FileReference::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FileReference::path() const {
  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileReference::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.path)
}
inline std::string* FileReference::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:aapt.pb.FileReference.path)
  return _s;
}
inline const std::string& FileReference::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FileReference::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FileReference::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FileReference::release_path() {
  // @@protoc_insertion_point(field_release:aapt.pb.FileReference.path)
  return _impl_.path_.Release();
}
inline void FileReference::set_allocated_path(std::string* path) {
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.FileReference.path)
}

// .aapt.pb.FileReference.Type type = 2;
inline void FileReference::clear_type() {
  _impl_.type_ = 0;
}
inline ::aapt::pb::FileReference_Type FileReference::_internal_type() const {
  return static_cast< ::aapt::pb::FileReference_Type >(_impl_.type_);
}
inline ::aapt::pb::FileReference_Type FileReference::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.type)
  return _internal_type();
}
inline void FileReference::_internal_set_type(::aapt::pb::FileReference_Type value) {
  
  _impl_.type_ = value;
}
inline void FileReference::set_type(::aapt::pb::FileReference_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.type)
}

// -------------------------------------------------------------------

// Primitive_NullType

// -------------------------------------------------------------------

// Primitive_EmptyType

// -------------------------------------------------------------------

// Primitive

// .aapt.pb.Primitive.NullType null_value = 1;
inline bool Primitive::_internal_has_null_value() const {
  return oneof_value_case() == kNullValue;
}
inline bool Primitive::has_null_value() const {
  return _internal_has_null_value();
}
inline void Primitive::set_has_null_value() {
  _impl_._oneof_case_[0] = kNullValue;
}
inline void Primitive::clear_null_value() {
  if (_internal_has_null_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_value_.null_value_;
    }
    clear_has_oneof_value();
  }
}
inline ::aapt::pb::Primitive_NullType* Primitive::release_null_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.Primitive.null_value)
  if (_internal_has_null_value()) {
    clear_has_oneof_value();
    ::aapt::pb::Primitive_NullType* temp = _impl_.oneof_value_.null_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_value_.null_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Primitive_NullType& Primitive::_internal_null_value() const {
  return _internal_has_null_value()
      ? *_impl_.oneof_value_.null_value_
      : reinterpret_cast< ::aapt::pb::Primitive_NullType&>(::aapt::pb::_Primitive_NullType_default_instance_);
}
inline const ::aapt::pb::Primitive_NullType& Primitive::null_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.null_value)
  return _internal_null_value();
}
inline ::aapt::pb::Primitive_NullType* Primitive::unsafe_arena_release_null_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Primitive.null_value)
  if (_internal_has_null_value()) {
    clear_has_oneof_value();
    ::aapt::pb::Primitive_NullType* temp = _impl_.oneof_value_.null_value_;
    _impl_.oneof_value_.null_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Primitive::unsafe_arena_set_allocated_null_value(::aapt::pb::Primitive_NullType* null_value) {
  clear_oneof_value();
  if (null_value) {
    set_has_null_value();
    _impl_.oneof_value_.null_value_ = null_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Primitive.null_value)
}
inline ::aapt::pb::Primitive_NullType* Primitive::_internal_mutable_null_value() {
  if (!_internal_has_null_value()) {
    clear_oneof_value();
    set_has_null_value();
    _impl_.oneof_value_.null_value_ = CreateMaybeMessage< ::aapt::pb::Primitive_NullType >(GetArenaForAllocation());
  }
  return _impl_.oneof_value_.null_value_;
}
inline ::aapt::pb::Primitive_NullType* Primitive::mutable_null_value() {
  ::aapt::pb::Primitive_NullType* _msg = _internal_mutable_null_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Primitive.null_value)
  return _msg;
}

// .aapt.pb.Primitive.EmptyType empty_value = 2;
inline bool Primitive::_internal_has_empty_value() const {
  return oneof_value_case() == kEmptyValue;
}
inline bool Primitive::has_empty_value() const {
  return _internal_has_empty_value();
}
inline void Primitive::set_has_empty_value() {
  _impl_._oneof_case_[0] = kEmptyValue;
}
inline void Primitive::clear_empty_value() {
  if (_internal_has_empty_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_value_.empty_value_;
    }
    clear_has_oneof_value();
  }
}
inline ::aapt::pb::Primitive_EmptyType* Primitive::release_empty_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.Primitive.empty_value)
  if (_internal_has_empty_value()) {
    clear_has_oneof_value();
    ::aapt::pb::Primitive_EmptyType* temp = _impl_.oneof_value_.empty_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_value_.empty_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::Primitive_EmptyType& Primitive::_internal_empty_value() const {
  return _internal_has_empty_value()
      ? *_impl_.oneof_value_.empty_value_
      : reinterpret_cast< ::aapt::pb::Primitive_EmptyType&>(::aapt::pb::_Primitive_EmptyType_default_instance_);
}
inline const ::aapt::pb::Primitive_EmptyType& Primitive::empty_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.empty_value)
  return _internal_empty_value();
}
inline ::aapt::pb::Primitive_EmptyType* Primitive::unsafe_arena_release_empty_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Primitive.empty_value)
  if (_internal_has_empty_value()) {
    clear_has_oneof_value();
    ::aapt::pb::Primitive_EmptyType* temp = _impl_.oneof_value_.empty_value_;
    _impl_.oneof_value_.empty_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Primitive::unsafe_arena_set_allocated_empty_value(::aapt::pb::Primitive_EmptyType* empty_value) {
  clear_oneof_value();
  if (empty_value) {
    set_has_empty_value();
    _impl_.oneof_value_.empty_value_ = empty_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Primitive.empty_value)
}
inline ::aapt::pb::Primitive_EmptyType* Primitive::_internal_mutable_empty_value() {
  if (!_internal_has_empty_value()) {
    clear_oneof_value();
    set_has_empty_value();
    _impl_.oneof_value_.empty_value_ = CreateMaybeMessage< ::aapt::pb::Primitive_EmptyType >(GetArenaForAllocation());
  }
  return _impl_.oneof_value_.empty_value_;
}
inline ::aapt::pb::Primitive_EmptyType* Primitive::mutable_empty_value() {
  ::aapt::pb::Primitive_EmptyType* _msg = _internal_mutable_empty_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Primitive.empty_value)
  return _msg;
}

// float float_value = 3;
inline bool Primitive::_internal_has_float_value() const {
  return oneof_value_case() == kFloatValue;
}
inline bool Primitive::has_float_value() const {
  return _internal_has_float_value();
}
inline void Primitive::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void Primitive::clear_float_value() {
  if (_internal_has_float_value()) {
    _impl_.oneof_value_.float_value_ = 0;
    clear_has_oneof_value();
  }
}
inline float Primitive::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return _impl_.oneof_value_.float_value_;
  }
  return 0;
}
inline void Primitive::_internal_set_float_value(float value) {
  if (!_internal_has_float_value()) {
    clear_oneof_value();
    set_has_float_value();
  }
  _impl_.oneof_value_.float_value_ = value;
}
inline float Primitive::float_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.float_value)
  return _internal_float_value();
}
inline void Primitive::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.float_value)
}

// uint32 dimension_value = 13;
inline bool Primitive::_internal_has_dimension_value() const {
  return oneof_value_case() == kDimensionValue;
}
inline bool Primitive::has_dimension_value() const {
  return _internal_has_dimension_value();
}
inline void Primitive::set_has_dimension_value() {
  _impl_._oneof_case_[0] = kDimensionValue;
}
inline void Primitive::clear_dimension_value() {
  if (_internal_has_dimension_value()) {
    _impl_.oneof_value_.dimension_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_dimension_value() const {
  if (_internal_has_dimension_value()) {
    return _impl_.oneof_value_.dimension_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_dimension_value(::uint32_t value) {
  if (!_internal_has_dimension_value()) {
    clear_oneof_value();
    set_has_dimension_value();
  }
  _impl_.oneof_value_.dimension_value_ = value;
}
inline ::uint32_t Primitive::dimension_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.dimension_value)
  return _internal_dimension_value();
}
inline void Primitive::set_dimension_value(::uint32_t value) {
  _internal_set_dimension_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.dimension_value)
}

// uint32 fraction_value = 14;
inline bool Primitive::_internal_has_fraction_value() const {
  return oneof_value_case() == kFractionValue;
}
inline bool Primitive::has_fraction_value() const {
  return _internal_has_fraction_value();
}
inline void Primitive::set_has_fraction_value() {
  _impl_._oneof_case_[0] = kFractionValue;
}
inline void Primitive::clear_fraction_value() {
  if (_internal_has_fraction_value()) {
    _impl_.oneof_value_.fraction_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_fraction_value() const {
  if (_internal_has_fraction_value()) {
    return _impl_.oneof_value_.fraction_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_fraction_value(::uint32_t value) {
  if (!_internal_has_fraction_value()) {
    clear_oneof_value();
    set_has_fraction_value();
  }
  _impl_.oneof_value_.fraction_value_ = value;
}
inline ::uint32_t Primitive::fraction_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.fraction_value)
  return _internal_fraction_value();
}
inline void Primitive::set_fraction_value(::uint32_t value) {
  _internal_set_fraction_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.fraction_value)
}

// int32 int_decimal_value = 6;
inline bool Primitive::_internal_has_int_decimal_value() const {
  return oneof_value_case() == kIntDecimalValue;
}
inline bool Primitive::has_int_decimal_value() const {
  return _internal_has_int_decimal_value();
}
inline void Primitive::set_has_int_decimal_value() {
  _impl_._oneof_case_[0] = kIntDecimalValue;
}
inline void Primitive::clear_int_decimal_value() {
  if (_internal_has_int_decimal_value()) {
    _impl_.oneof_value_.int_decimal_value_ = 0;
    clear_has_oneof_value();
  }
}
inline ::int32_t Primitive::_internal_int_decimal_value() const {
  if (_internal_has_int_decimal_value()) {
    return _impl_.oneof_value_.int_decimal_value_;
  }
  return 0;
}
inline void Primitive::_internal_set_int_decimal_value(::int32_t value) {
  if (!_internal_has_int_decimal_value()) {
    clear_oneof_value();
    set_has_int_decimal_value();
  }
  _impl_.oneof_value_.int_decimal_value_ = value;
}
inline ::int32_t Primitive::int_decimal_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.int_decimal_value)
  return _internal_int_decimal_value();
}
inline void Primitive::set_int_decimal_value(::int32_t value) {
  _internal_set_int_decimal_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.int_decimal_value)
}

// uint32 int_hexadecimal_value = 7;
inline bool Primitive::_internal_has_int_hexadecimal_value() const {
  return oneof_value_case() == kIntHexadecimalValue;
}
inline bool Primitive::has_int_hexadecimal_value() const {
  return _internal_has_int_hexadecimal_value();
}
inline void Primitive::set_has_int_hexadecimal_value() {
  _impl_._oneof_case_[0] = kIntHexadecimalValue;
}
inline void Primitive::clear_int_hexadecimal_value() {
  if (_internal_has_int_hexadecimal_value()) {
    _impl_.oneof_value_.int_hexadecimal_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_int_hexadecimal_value() const {
  if (_internal_has_int_hexadecimal_value()) {
    return _impl_.oneof_value_.int_hexadecimal_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_int_hexadecimal_value(::uint32_t value) {
  if (!_internal_has_int_hexadecimal_value()) {
    clear_oneof_value();
    set_has_int_hexadecimal_value();
  }
  _impl_.oneof_value_.int_hexadecimal_value_ = value;
}
inline ::uint32_t Primitive::int_hexadecimal_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.int_hexadecimal_value)
  return _internal_int_hexadecimal_value();
}
inline void Primitive::set_int_hexadecimal_value(::uint32_t value) {
  _internal_set_int_hexadecimal_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.int_hexadecimal_value)
}

// bool boolean_value = 8;
inline bool Primitive::_internal_has_boolean_value() const {
  return oneof_value_case() == kBooleanValue;
}
inline bool Primitive::has_boolean_value() const {
  return _internal_has_boolean_value();
}
inline void Primitive::set_has_boolean_value() {
  _impl_._oneof_case_[0] = kBooleanValue;
}
inline void Primitive::clear_boolean_value() {
  if (_internal_has_boolean_value()) {
    _impl_.oneof_value_.boolean_value_ = false;
    clear_has_oneof_value();
  }
}
inline bool Primitive::_internal_boolean_value() const {
  if (_internal_has_boolean_value()) {
    return _impl_.oneof_value_.boolean_value_;
  }
  return false;
}
inline void Primitive::_internal_set_boolean_value(bool value) {
  if (!_internal_has_boolean_value()) {
    clear_oneof_value();
    set_has_boolean_value();
  }
  _impl_.oneof_value_.boolean_value_ = value;
}
inline bool Primitive::boolean_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.boolean_value)
  return _internal_boolean_value();
}
inline void Primitive::set_boolean_value(bool value) {
  _internal_set_boolean_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.boolean_value)
}

// uint32 color_argb8_value = 9;
inline bool Primitive::_internal_has_color_argb8_value() const {
  return oneof_value_case() == kColorArgb8Value;
}
inline bool Primitive::has_color_argb8_value() const {
  return _internal_has_color_argb8_value();
}
inline void Primitive::set_has_color_argb8_value() {
  _impl_._oneof_case_[0] = kColorArgb8Value;
}
inline void Primitive::clear_color_argb8_value() {
  if (_internal_has_color_argb8_value()) {
    _impl_.oneof_value_.color_argb8_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_color_argb8_value() const {
  if (_internal_has_color_argb8_value()) {
    return _impl_.oneof_value_.color_argb8_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_color_argb8_value(::uint32_t value) {
  if (!_internal_has_color_argb8_value()) {
    clear_oneof_value();
    set_has_color_argb8_value();
  }
  _impl_.oneof_value_.color_argb8_value_ = value;
}
inline ::uint32_t Primitive::color_argb8_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_argb8_value)
  return _internal_color_argb8_value();
}
inline void Primitive::set_color_argb8_value(::uint32_t value) {
  _internal_set_color_argb8_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_argb8_value)
}

// uint32 color_rgb8_value = 10;
inline bool Primitive::_internal_has_color_rgb8_value() const {
  return oneof_value_case() == kColorRgb8Value;
}
inline bool Primitive::has_color_rgb8_value() const {
  return _internal_has_color_rgb8_value();
}
inline void Primitive::set_has_color_rgb8_value() {
  _impl_._oneof_case_[0] = kColorRgb8Value;
}
inline void Primitive::clear_color_rgb8_value() {
  if (_internal_has_color_rgb8_value()) {
    _impl_.oneof_value_.color_rgb8_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_color_rgb8_value() const {
  if (_internal_has_color_rgb8_value()) {
    return _impl_.oneof_value_.color_rgb8_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_color_rgb8_value(::uint32_t value) {
  if (!_internal_has_color_rgb8_value()) {
    clear_oneof_value();
    set_has_color_rgb8_value();
  }
  _impl_.oneof_value_.color_rgb8_value_ = value;
}
inline ::uint32_t Primitive::color_rgb8_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_rgb8_value)
  return _internal_color_rgb8_value();
}
inline void Primitive::set_color_rgb8_value(::uint32_t value) {
  _internal_set_color_rgb8_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_rgb8_value)
}

// uint32 color_argb4_value = 11;
inline bool Primitive::_internal_has_color_argb4_value() const {
  return oneof_value_case() == kColorArgb4Value;
}
inline bool Primitive::has_color_argb4_value() const {
  return _internal_has_color_argb4_value();
}
inline void Primitive::set_has_color_argb4_value() {
  _impl_._oneof_case_[0] = kColorArgb4Value;
}
inline void Primitive::clear_color_argb4_value() {
  if (_internal_has_color_argb4_value()) {
    _impl_.oneof_value_.color_argb4_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_color_argb4_value() const {
  if (_internal_has_color_argb4_value()) {
    return _impl_.oneof_value_.color_argb4_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_color_argb4_value(::uint32_t value) {
  if (!_internal_has_color_argb4_value()) {
    clear_oneof_value();
    set_has_color_argb4_value();
  }
  _impl_.oneof_value_.color_argb4_value_ = value;
}
inline ::uint32_t Primitive::color_argb4_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_argb4_value)
  return _internal_color_argb4_value();
}
inline void Primitive::set_color_argb4_value(::uint32_t value) {
  _internal_set_color_argb4_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_argb4_value)
}

// uint32 color_rgb4_value = 12;
inline bool Primitive::_internal_has_color_rgb4_value() const {
  return oneof_value_case() == kColorRgb4Value;
}
inline bool Primitive::has_color_rgb4_value() const {
  return _internal_has_color_rgb4_value();
}
inline void Primitive::set_has_color_rgb4_value() {
  _impl_._oneof_case_[0] = kColorRgb4Value;
}
inline void Primitive::clear_color_rgb4_value() {
  if (_internal_has_color_rgb4_value()) {
    _impl_.oneof_value_.color_rgb4_value_ = 0u;
    clear_has_oneof_value();
  }
}
inline ::uint32_t Primitive::_internal_color_rgb4_value() const {
  if (_internal_has_color_rgb4_value()) {
    return _impl_.oneof_value_.color_rgb4_value_;
  }
  return 0u;
}
inline void Primitive::_internal_set_color_rgb4_value(::uint32_t value) {
  if (!_internal_has_color_rgb4_value()) {
    clear_oneof_value();
    set_has_color_rgb4_value();
  }
  _impl_.oneof_value_.color_rgb4_value_ = value;
}
inline ::uint32_t Primitive::color_rgb4_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_rgb4_value)
  return _internal_color_rgb4_value();
}
inline void Primitive::set_color_rgb4_value(::uint32_t value) {
  _internal_set_color_rgb4_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_rgb4_value)
}

// float dimension_value_deprecated = 4 [deprecated = true];
inline bool Primitive::_internal_has_dimension_value_deprecated() const {
  return oneof_value_case() == kDimensionValueDeprecated;
}
inline bool Primitive::has_dimension_value_deprecated() const {
  return _internal_has_dimension_value_deprecated();
}
inline void Primitive::set_has_dimension_value_deprecated() {
  _impl_._oneof_case_[0] = kDimensionValueDeprecated;
}
inline void Primitive::clear_dimension_value_deprecated() {
  if (_internal_has_dimension_value_deprecated()) {
    _impl_.oneof_value_.dimension_value_deprecated_ = 0;
    clear_has_oneof_value();
  }
}
inline float Primitive::_internal_dimension_value_deprecated() const {
  if (_internal_has_dimension_value_deprecated()) {
    return _impl_.oneof_value_.dimension_value_deprecated_;
  }
  return 0;
}
inline void Primitive::_internal_set_dimension_value_deprecated(float value) {
  if (!_internal_has_dimension_value_deprecated()) {
    clear_oneof_value();
    set_has_dimension_value_deprecated();
  }
  _impl_.oneof_value_.dimension_value_deprecated_ = value;
}
inline float Primitive::dimension_value_deprecated() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.dimension_value_deprecated)
  return _internal_dimension_value_deprecated();
}
inline void Primitive::set_dimension_value_deprecated(float value) {
  _internal_set_dimension_value_deprecated(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.dimension_value_deprecated)
}

// float fraction_value_deprecated = 5 [deprecated = true];
inline bool Primitive::_internal_has_fraction_value_deprecated() const {
  return oneof_value_case() == kFractionValueDeprecated;
}
inline bool Primitive::has_fraction_value_deprecated() const {
  return _internal_has_fraction_value_deprecated();
}
inline void Primitive::set_has_fraction_value_deprecated() {
  _impl_._oneof_case_[0] = kFractionValueDeprecated;
}
inline void Primitive::clear_fraction_value_deprecated() {
  if (_internal_has_fraction_value_deprecated()) {
    _impl_.oneof_value_.fraction_value_deprecated_ = 0;
    clear_has_oneof_value();
  }
}
inline float Primitive::_internal_fraction_value_deprecated() const {
  if (_internal_has_fraction_value_deprecated()) {
    return _impl_.oneof_value_.fraction_value_deprecated_;
  }
  return 0;
}
inline void Primitive::_internal_set_fraction_value_deprecated(float value) {
  if (!_internal_has_fraction_value_deprecated()) {
    clear_oneof_value();
    set_has_fraction_value_deprecated();
  }
  _impl_.oneof_value_.fraction_value_deprecated_ = value;
}
inline float Primitive::fraction_value_deprecated() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.fraction_value_deprecated)
  return _internal_fraction_value_deprecated();
}
inline void Primitive::set_fraction_value_deprecated(float value) {
  _internal_set_fraction_value_deprecated(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.fraction_value_deprecated)
}

inline bool Primitive::has_oneof_value() const {
  return oneof_value_case() != ONEOF_VALUE_NOT_SET;
}
inline void Primitive::clear_has_oneof_value() {
  _impl_._oneof_case_[0] = ONEOF_VALUE_NOT_SET;
}
inline Primitive::OneofValueCase Primitive::oneof_value_case() const {
  return Primitive::OneofValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Attribute_Symbol

// .aapt.pb.Source source = 1;
inline bool Attribute_Symbol::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Attribute_Symbol::has_source() const {
  return _internal_has_source();
}
inline void Attribute_Symbol::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Attribute_Symbol::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Attribute_Symbol::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.source)
  return _internal_source();
}
inline void Attribute_Symbol::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Attribute.Symbol.source)
}
inline ::aapt::pb::Source* Attribute_Symbol::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Attribute_Symbol::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Attribute_Symbol::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Attribute_Symbol::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.source)
  return _msg;
}
inline void Attribute_Symbol::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.source)
}

// string comment = 2;
inline void Attribute_Symbol::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Attribute_Symbol::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribute_Symbol::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.comment)
}
inline std::string* Attribute_Symbol::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.comment)
  return _s;
}
inline const std::string& Attribute_Symbol::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Attribute_Symbol::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribute_Symbol::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribute_Symbol::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.comment)
  return _impl_.comment_.Release();
}
inline void Attribute_Symbol::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.comment)
}

// .aapt.pb.Reference name = 3;
inline bool Attribute_Symbol::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool Attribute_Symbol::has_name() const {
  return _internal_has_name();
}
inline void Attribute_Symbol::clear_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
}
inline const ::aapt::pb::Reference& Attribute_Symbol::_internal_name() const {
  const ::aapt::pb::Reference* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
      ::aapt::pb::_Reference_default_instance_);
}
inline const ::aapt::pb::Reference& Attribute_Symbol::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.name)
  return _internal_name();
}
inline void Attribute_Symbol::unsafe_arena_set_allocated_name(
    ::aapt::pb::Reference* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Attribute.Symbol.name)
}
inline ::aapt::pb::Reference* Attribute_Symbol::release_name() {
  
  ::aapt::pb::Reference* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Reference* Attribute_Symbol::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.name)
  
  ::aapt::pb::Reference* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::aapt::pb::Reference* Attribute_Symbol::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::aapt::pb::Reference* Attribute_Symbol::mutable_name() {
  ::aapt::pb::Reference* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.name)
  return _msg;
}
inline void Attribute_Symbol::set_allocated_name(::aapt::pb::Reference* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.name)
}

// uint32 value = 4;
inline void Attribute_Symbol::clear_value() {
  _impl_.value_ = 0u;
}
inline ::uint32_t Attribute_Symbol::_internal_value() const {
  return _impl_.value_;
}
inline ::uint32_t Attribute_Symbol::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.value)
  return _internal_value();
}
inline void Attribute_Symbol::_internal_set_value(::uint32_t value) {
  
  _impl_.value_ = value;
}
inline void Attribute_Symbol::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.value)
}

// uint32 type = 5;
inline void Attribute_Symbol::clear_type() {
  _impl_.type_ = 0u;
}
inline ::uint32_t Attribute_Symbol::_internal_type() const {
  return _impl_.type_;
}
inline ::uint32_t Attribute_Symbol::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.type)
  return _internal_type();
}
inline void Attribute_Symbol::_internal_set_type(::uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Attribute_Symbol::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.type)
}

// -------------------------------------------------------------------

// Attribute

// uint32 format_flags = 1;
inline void Attribute::clear_format_flags() {
  _impl_.format_flags_ = 0u;
}
inline ::uint32_t Attribute::_internal_format_flags() const {
  return _impl_.format_flags_;
}
inline ::uint32_t Attribute::format_flags() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.format_flags)
  return _internal_format_flags();
}
inline void Attribute::_internal_set_format_flags(::uint32_t value) {
  
  _impl_.format_flags_ = value;
}
inline void Attribute::set_format_flags(::uint32_t value) {
  _internal_set_format_flags(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.format_flags)
}

// int32 min_int = 2;
inline void Attribute::clear_min_int() {
  _impl_.min_int_ = 0;
}
inline ::int32_t Attribute::_internal_min_int() const {
  return _impl_.min_int_;
}
inline ::int32_t Attribute::min_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.min_int)
  return _internal_min_int();
}
inline void Attribute::_internal_set_min_int(::int32_t value) {
  
  _impl_.min_int_ = value;
}
inline void Attribute::set_min_int(::int32_t value) {
  _internal_set_min_int(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.min_int)
}

// int32 max_int = 3;
inline void Attribute::clear_max_int() {
  _impl_.max_int_ = 0;
}
inline ::int32_t Attribute::_internal_max_int() const {
  return _impl_.max_int_;
}
inline ::int32_t Attribute::max_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.max_int)
  return _internal_max_int();
}
inline void Attribute::_internal_set_max_int(::int32_t value) {
  
  _impl_.max_int_ = value;
}
inline void Attribute::set_max_int(::int32_t value) {
  _internal_set_max_int(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.max_int)
}

// repeated .aapt.pb.Attribute.Symbol symbol = 4;
inline int Attribute::_internal_symbol_size() const {
  return _impl_.symbol_.size();
}
inline int Attribute::symbol_size() const {
  return _internal_symbol_size();
}
inline void Attribute::clear_symbol() {
  _impl_.symbol_.Clear();
}
inline ::aapt::pb::Attribute_Symbol* Attribute::mutable_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.symbol)
  return _impl_.symbol_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
Attribute::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Attribute.symbol)
  return &_impl_.symbol_;
}
inline const ::aapt::pb::Attribute_Symbol& Attribute::_internal_symbol(int index) const {
  return _impl_.symbol_.Get(index);
}
inline const ::aapt::pb::Attribute_Symbol& Attribute::symbol(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.symbol)
  return _internal_symbol(index);
}
inline ::aapt::pb::Attribute_Symbol* Attribute::_internal_add_symbol() {
  return _impl_.symbol_.Add();
}
inline ::aapt::pb::Attribute_Symbol* Attribute::add_symbol() {
  ::aapt::pb::Attribute_Symbol* _add = _internal_add_symbol();
  // @@protoc_insertion_point(field_add:aapt.pb.Attribute.symbol)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
Attribute::symbol() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Attribute.symbol)
  return _impl_.symbol_;
}

// -------------------------------------------------------------------

// Style_Entry

// .aapt.pb.Source source = 1;
inline bool Style_Entry::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Style_Entry::has_source() const {
  return _internal_has_source();
}
inline void Style_Entry::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Style_Entry::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Style_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.source)
  return _internal_source();
}
inline void Style_Entry::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.source)
}
inline ::aapt::pb::Source* Style_Entry::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Style_Entry::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Style_Entry::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Style_Entry::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.source)
  return _msg;
}
inline void Style_Entry::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.source)
}

// string comment = 2;
inline void Style_Entry::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Style_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Style_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Style.Entry.comment)
}
inline std::string* Style_Entry::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.comment)
  return _s;
}
inline const std::string& Style_Entry::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Style_Entry::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Style_Entry::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Style_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.comment)
  return _impl_.comment_.Release();
}
inline void Style_Entry::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.comment)
}

// .aapt.pb.Reference key = 3;
inline bool Style_Entry::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool Style_Entry::has_key() const {
  return _internal_has_key();
}
inline void Style_Entry::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::aapt::pb::Reference& Style_Entry::_internal_key() const {
  const ::aapt::pb::Reference* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
      ::aapt::pb::_Reference_default_instance_);
}
inline const ::aapt::pb::Reference& Style_Entry::key() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.key)
  return _internal_key();
}
inline void Style_Entry::unsafe_arena_set_allocated_key(
    ::aapt::pb::Reference* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.key)
}
inline ::aapt::pb::Reference* Style_Entry::release_key() {
  
  ::aapt::pb::Reference* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Reference* Style_Entry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.key)
  
  ::aapt::pb::Reference* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::aapt::pb::Reference* Style_Entry::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::aapt::pb::Reference* Style_Entry::mutable_key() {
  ::aapt::pb::Reference* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.key)
  return _msg;
}
inline void Style_Entry::set_allocated_key(::aapt::pb::Reference* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.key)
}

// .aapt.pb.Item item = 4;
inline bool Style_Entry::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool Style_Entry::has_item() const {
  return _internal_has_item();
}
inline void Style_Entry::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::aapt::pb::Item& Style_Entry::_internal_item() const {
  const ::aapt::pb::Item* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
      ::aapt::pb::_Item_default_instance_);
}
inline const ::aapt::pb::Item& Style_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.item)
  return _internal_item();
}
inline void Style_Entry::unsafe_arena_set_allocated_item(
    ::aapt::pb::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.item)
}
inline ::aapt::pb::Item* Style_Entry::release_item() {
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Item* Style_Entry::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.item)
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::aapt::pb::Item* Style_Entry::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::aapt::pb::Item* Style_Entry::mutable_item() {
  ::aapt::pb::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.item)
  return _msg;
}
inline void Style_Entry::set_allocated_item(::aapt::pb::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.item)
}

// -------------------------------------------------------------------

// Style

// .aapt.pb.Reference parent = 1;
inline bool Style::_internal_has_parent() const {
  return this != internal_default_instance() && _impl_.parent_ != nullptr;
}
inline bool Style::has_parent() const {
  return _internal_has_parent();
}
inline void Style::clear_parent() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
    delete _impl_.parent_;
  }
  _impl_.parent_ = nullptr;
}
inline const ::aapt::pb::Reference& Style::_internal_parent() const {
  const ::aapt::pb::Reference* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
      ::aapt::pb::_Reference_default_instance_);
}
inline const ::aapt::pb::Reference& Style::parent() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent)
  return _internal_parent();
}
inline void Style::unsafe_arena_set_allocated_parent(
    ::aapt::pb::Reference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.parent)
}
inline ::aapt::pb::Reference* Style::release_parent() {
  
  ::aapt::pb::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Reference* Style::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent)
  
  ::aapt::pb::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::aapt::pb::Reference* Style::_internal_mutable_parent() {
  
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::aapt::pb::Reference* Style::mutable_parent() {
  ::aapt::pb::Reference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent)
  return _msg;
}
inline void Style::set_allocated_parent(::aapt::pb::Reference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent)
}

// .aapt.pb.Source parent_source = 2;
inline bool Style::_internal_has_parent_source() const {
  return this != internal_default_instance() && _impl_.parent_source_ != nullptr;
}
inline bool Style::has_parent_source() const {
  return _internal_has_parent_source();
}
inline void Style::clear_parent_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_source_ != nullptr) {
    delete _impl_.parent_source_;
  }
  _impl_.parent_source_ = nullptr;
}
inline const ::aapt::pb::Source& Style::_internal_parent_source() const {
  const ::aapt::pb::Source* p = _impl_.parent_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Style::parent_source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent_source)
  return _internal_parent_source();
}
inline void Style::unsafe_arena_set_allocated_parent_source(
    ::aapt::pb::Source* parent_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_source_);
  }
  _impl_.parent_source_ = parent_source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.parent_source)
}
inline ::aapt::pb::Source* Style::release_parent_source() {
  
  ::aapt::pb::Source* temp = _impl_.parent_source_;
  _impl_.parent_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Style::unsafe_arena_release_parent_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent_source)
  
  ::aapt::pb::Source* temp = _impl_.parent_source_;
  _impl_.parent_source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Style::_internal_mutable_parent_source() {
  
  if (_impl_.parent_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.parent_source_ = p;
  }
  return _impl_.parent_source_;
}
inline ::aapt::pb::Source* Style::mutable_parent_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_parent_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent_source)
  return _msg;
}
inline void Style::set_allocated_parent_source(::aapt::pb::Source* parent_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_source_;
  }
  if (parent_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent_source);
    if (message_arena != submessage_arena) {
      parent_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_source_ = parent_source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent_source)
}

// repeated .aapt.pb.Style.Entry entry = 3;
inline int Style::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int Style::entry_size() const {
  return _internal_entry_size();
}
inline void Style::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::aapt::pb::Style_Entry* Style::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >*
Style::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Style.entry)
  return &_impl_.entry_;
}
inline const ::aapt::pb::Style_Entry& Style::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::aapt::pb::Style_Entry& Style::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.entry)
  return _internal_entry(index);
}
inline ::aapt::pb::Style_Entry* Style::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::aapt::pb::Style_Entry* Style::add_entry() {
  ::aapt::pb::Style_Entry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:aapt.pb.Style.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >&
Style::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Style.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// Styleable_Entry

// .aapt.pb.Source source = 1;
inline bool Styleable_Entry::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Styleable_Entry::has_source() const {
  return _internal_has_source();
}
inline void Styleable_Entry::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Styleable_Entry::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Styleable_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.source)
  return _internal_source();
}
inline void Styleable_Entry::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Styleable.Entry.source)
}
inline ::aapt::pb::Source* Styleable_Entry::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Styleable_Entry::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Styleable_Entry::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Styleable_Entry::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.source)
  return _msg;
}
inline void Styleable_Entry::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.source)
}

// string comment = 2;
inline void Styleable_Entry::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Styleable_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Styleable_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Styleable.Entry.comment)
}
inline std::string* Styleable_Entry::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.comment)
  return _s;
}
inline const std::string& Styleable_Entry::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Styleable_Entry::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Styleable_Entry::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Styleable_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.comment)
  return _impl_.comment_.Release();
}
inline void Styleable_Entry::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.comment)
}

// .aapt.pb.Reference attr = 3;
inline bool Styleable_Entry::_internal_has_attr() const {
  return this != internal_default_instance() && _impl_.attr_ != nullptr;
}
inline bool Styleable_Entry::has_attr() const {
  return _internal_has_attr();
}
inline void Styleable_Entry::clear_attr() {
  if (GetArenaForAllocation() == nullptr && _impl_.attr_ != nullptr) {
    delete _impl_.attr_;
  }
  _impl_.attr_ = nullptr;
}
inline const ::aapt::pb::Reference& Styleable_Entry::_internal_attr() const {
  const ::aapt::pb::Reference* p = _impl_.attr_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
      ::aapt::pb::_Reference_default_instance_);
}
inline const ::aapt::pb::Reference& Styleable_Entry::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.attr)
  return _internal_attr();
}
inline void Styleable_Entry::unsafe_arena_set_allocated_attr(
    ::aapt::pb::Reference* attr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attr_);
  }
  _impl_.attr_ = attr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Styleable.Entry.attr)
}
inline ::aapt::pb::Reference* Styleable_Entry::release_attr() {
  
  ::aapt::pb::Reference* temp = _impl_.attr_;
  _impl_.attr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Reference* Styleable_Entry::unsafe_arena_release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.attr)
  
  ::aapt::pb::Reference* temp = _impl_.attr_;
  _impl_.attr_ = nullptr;
  return temp;
}
inline ::aapt::pb::Reference* Styleable_Entry::_internal_mutable_attr() {
  
  if (_impl_.attr_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
    _impl_.attr_ = p;
  }
  return _impl_.attr_;
}
inline ::aapt::pb::Reference* Styleable_Entry::mutable_attr() {
  ::aapt::pb::Reference* _msg = _internal_mutable_attr();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.attr)
  return _msg;
}
inline void Styleable_Entry::set_allocated_attr(::aapt::pb::Reference* attr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attr_;
  }
  if (attr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attr);
    if (message_arena != submessage_arena) {
      attr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attr_ = attr;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.attr)
}

// -------------------------------------------------------------------

// Styleable

// repeated .aapt.pb.Styleable.Entry entry = 1;
inline int Styleable::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int Styleable::entry_size() const {
  return _internal_entry_size();
}
inline void Styleable::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::aapt::pb::Styleable_Entry* Styleable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
Styleable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Styleable.entry)
  return &_impl_.entry_;
}
inline const ::aapt::pb::Styleable_Entry& Styleable::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::aapt::pb::Styleable_Entry& Styleable::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.entry)
  return _internal_entry(index);
}
inline ::aapt::pb::Styleable_Entry* Styleable::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::aapt::pb::Styleable_Entry* Styleable::add_entry() {
  ::aapt::pb::Styleable_Entry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:aapt.pb.Styleable.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
Styleable::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Styleable.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// Array_Element

// .aapt.pb.Source source = 1;
inline bool Array_Element::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Array_Element::has_source() const {
  return _internal_has_source();
}
inline void Array_Element::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Array_Element::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Array_Element::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.source)
  return _internal_source();
}
inline void Array_Element::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Array.Element.source)
}
inline ::aapt::pb::Source* Array_Element::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Array_Element::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Array_Element::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Array_Element::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.source)
  return _msg;
}
inline void Array_Element::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.source)
}

// string comment = 2;
inline void Array_Element::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Array_Element::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Array_Element::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Array.Element.comment)
}
inline std::string* Array_Element::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.comment)
  return _s;
}
inline const std::string& Array_Element::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Array_Element::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Array_Element::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Array_Element::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.comment)
  return _impl_.comment_.Release();
}
inline void Array_Element::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.comment)
}

// .aapt.pb.Item item = 3;
inline bool Array_Element::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool Array_Element::has_item() const {
  return _internal_has_item();
}
inline void Array_Element::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::aapt::pb::Item& Array_Element::_internal_item() const {
  const ::aapt::pb::Item* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
      ::aapt::pb::_Item_default_instance_);
}
inline const ::aapt::pb::Item& Array_Element::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.item)
  return _internal_item();
}
inline void Array_Element::unsafe_arena_set_allocated_item(
    ::aapt::pb::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Array.Element.item)
}
inline ::aapt::pb::Item* Array_Element::release_item() {
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Item* Array_Element::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.item)
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::aapt::pb::Item* Array_Element::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::aapt::pb::Item* Array_Element::mutable_item() {
  ::aapt::pb::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.item)
  return _msg;
}
inline void Array_Element::set_allocated_item(::aapt::pb::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.item)
}

// -------------------------------------------------------------------

// Array

// repeated .aapt.pb.Array.Element element = 1;
inline int Array::_internal_element_size() const {
  return _impl_.element_.size();
}
inline int Array::element_size() const {
  return _internal_element_size();
}
inline void Array::clear_element() {
  _impl_.element_.Clear();
}
inline ::aapt::pb::Array_Element* Array::mutable_element(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.element)
  return _impl_.element_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >*
Array::mutable_element() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Array.element)
  return &_impl_.element_;
}
inline const ::aapt::pb::Array_Element& Array::_internal_element(int index) const {
  return _impl_.element_.Get(index);
}
inline const ::aapt::pb::Array_Element& Array::element(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.element)
  return _internal_element(index);
}
inline ::aapt::pb::Array_Element* Array::_internal_add_element() {
  return _impl_.element_.Add();
}
inline ::aapt::pb::Array_Element* Array::add_element() {
  ::aapt::pb::Array_Element* _add = _internal_add_element();
  // @@protoc_insertion_point(field_add:aapt.pb.Array.element)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >&
Array::element() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Array.element)
  return _impl_.element_;
}

// -------------------------------------------------------------------

// Plural_Entry

// .aapt.pb.Source source = 1;
inline bool Plural_Entry::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Plural_Entry::has_source() const {
  return _internal_has_source();
}
inline void Plural_Entry::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::Source& Plural_Entry::_internal_source() const {
  const ::aapt::pb::Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
      ::aapt::pb::_Source_default_instance_);
}
inline const ::aapt::pb::Source& Plural_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.source)
  return _internal_source();
}
inline void Plural_Entry::unsafe_arena_set_allocated_source(
    ::aapt::pb::Source* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Plural.Entry.source)
}
inline ::aapt::pb::Source* Plural_Entry::release_source() {
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Source* Plural_Entry::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.source)
  
  ::aapt::pb::Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::Source* Plural_Entry::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::Source* Plural_Entry::mutable_source() {
  ::aapt::pb::Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.source)
  return _msg;
}
inline void Plural_Entry::set_allocated_source(::aapt::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.source)
}

// string comment = 2;
inline void Plural_Entry::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Plural_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plural_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.comment)
}
inline std::string* Plural_Entry::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.comment)
  return _s;
}
inline const std::string& Plural_Entry::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Plural_Entry::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Plural_Entry::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Plural_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.comment)
  return _impl_.comment_.Release();
}
inline void Plural_Entry::set_allocated_comment(std::string* comment) {
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.comment)
}

// .aapt.pb.Plural.Arity arity = 3;
inline void Plural_Entry::clear_arity() {
  _impl_.arity_ = 0;
}
inline ::aapt::pb::Plural_Arity Plural_Entry::_internal_arity() const {
  return static_cast< ::aapt::pb::Plural_Arity >(_impl_.arity_);
}
inline ::aapt::pb::Plural_Arity Plural_Entry::arity() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.arity)
  return _internal_arity();
}
inline void Plural_Entry::_internal_set_arity(::aapt::pb::Plural_Arity value) {
  
  _impl_.arity_ = value;
}
inline void Plural_Entry::set_arity(::aapt::pb::Plural_Arity value) {
  _internal_set_arity(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.arity)
}

// .aapt.pb.Item item = 4;
inline bool Plural_Entry::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool Plural_Entry::has_item() const {
  return _internal_has_item();
}
inline void Plural_Entry::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::aapt::pb::Item& Plural_Entry::_internal_item() const {
  const ::aapt::pb::Item* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
      ::aapt::pb::_Item_default_instance_);
}
inline const ::aapt::pb::Item& Plural_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.item)
  return _internal_item();
}
inline void Plural_Entry::unsafe_arena_set_allocated_item(
    ::aapt::pb::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Plural.Entry.item)
}
inline ::aapt::pb::Item* Plural_Entry::release_item() {
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Item* Plural_Entry::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.item)
  
  ::aapt::pb::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::aapt::pb::Item* Plural_Entry::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::aapt::pb::Item* Plural_Entry::mutable_item() {
  ::aapt::pb::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.item)
  return _msg;
}
inline void Plural_Entry::set_allocated_item(::aapt::pb::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.item)
}

// -------------------------------------------------------------------

// Plural

// repeated .aapt.pb.Plural.Entry entry = 1;
inline int Plural::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int Plural::entry_size() const {
  return _internal_entry_size();
}
inline void Plural::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::aapt::pb::Plural_Entry* Plural::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
Plural::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Plural.entry)
  return &_impl_.entry_;
}
inline const ::aapt::pb::Plural_Entry& Plural::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::aapt::pb::Plural_Entry& Plural::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.entry)
  return _internal_entry(index);
}
inline ::aapt::pb::Plural_Entry* Plural::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::aapt::pb::Plural_Entry* Plural::add_entry() {
  ::aapt::pb::Plural_Entry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:aapt.pb.Plural.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
Plural::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Plural.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// XmlNode

// .aapt.pb.XmlElement element = 1;
inline bool XmlNode::_internal_has_element() const {
  return node_case() == kElement;
}
inline bool XmlNode::has_element() const {
  return _internal_has_element();
}
inline void XmlNode::set_has_element() {
  _impl_._oneof_case_[0] = kElement;
}
inline void XmlNode::clear_element() {
  if (_internal_has_element()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.node_.element_;
    }
    clear_has_node();
  }
}
inline ::aapt::pb::XmlElement* XmlNode::release_element() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.element)
  if (_internal_has_element()) {
    clear_has_node();
    ::aapt::pb::XmlElement* temp = _impl_.node_.element_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_.element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aapt::pb::XmlElement& XmlNode::_internal_element() const {
  return _internal_has_element()
      ? *_impl_.node_.element_
      : reinterpret_cast< ::aapt::pb::XmlElement&>(::aapt::pb::_XmlElement_default_instance_);
}
inline const ::aapt::pb::XmlElement& XmlNode::element() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.element)
  return _internal_element();
}
inline ::aapt::pb::XmlElement* XmlNode::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.XmlNode.element)
  if (_internal_has_element()) {
    clear_has_node();
    ::aapt::pb::XmlElement* temp = _impl_.node_.element_;
    _impl_.node_.element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XmlNode::unsafe_arena_set_allocated_element(::aapt::pb::XmlElement* element) {
  clear_node();
  if (element) {
    set_has_element();
    _impl_.node_.element_ = element;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNode.element)
}
inline ::aapt::pb::XmlElement* XmlNode::_internal_mutable_element() {
  if (!_internal_has_element()) {
    clear_node();
    set_has_element();
    _impl_.node_.element_ = CreateMaybeMessage< ::aapt::pb::XmlElement >(GetArenaForAllocation());
  }
  return _impl_.node_.element_;
}
inline ::aapt::pb::XmlElement* XmlNode::mutable_element() {
  ::aapt::pb::XmlElement* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.element)
  return _msg;
}

// string text = 2;
inline bool XmlNode::_internal_has_text() const {
  return node_case() == kText;
}
inline bool XmlNode::has_text() const {
  return _internal_has_text();
}
inline void XmlNode::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void XmlNode::clear_text() {
  if (_internal_has_text()) {
    _impl_.node_.text_.Destroy();
    clear_has_node();
  }
}
inline const std::string& XmlNode::text() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void XmlNode::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_node();
    set_has_text();
    _impl_.node_.text_.InitDefault();
  }
  _impl_.node_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNode.text)
}
inline std::string* XmlNode::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.text)
  return _s;
}
inline const std::string& XmlNode::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.node_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void XmlNode::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_node();
    set_has_text();
    _impl_.node_.text_.InitDefault();
  }
  _impl_.node_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlNode::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_node();
    set_has_text();
    _impl_.node_.text_.InitDefault();
  }
  return _impl_.node_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* XmlNode::release_text() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.text)
  if (_internal_has_text()) {
    clear_has_node();
    return _impl_.node_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void XmlNode::set_allocated_text(std::string* text) {
  if (has_node()) {
    clear_node();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.node_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.text)
}

// .aapt.pb.SourcePosition source = 3;
inline bool XmlNode::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool XmlNode::has_source() const {
  return _internal_has_source();
}
inline void XmlNode::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::SourcePosition& XmlNode::_internal_source() const {
  const ::aapt::pb::SourcePosition* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
      ::aapt::pb::_SourcePosition_default_instance_);
}
inline const ::aapt::pb::SourcePosition& XmlNode::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.source)
  return _internal_source();
}
inline void XmlNode::unsafe_arena_set_allocated_source(
    ::aapt::pb::SourcePosition* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNode.source)
}
inline ::aapt::pb::SourcePosition* XmlNode::release_source() {
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlNode::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.source)
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlNode::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::SourcePosition* XmlNode::mutable_source() {
  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.source)
  return _msg;
}
inline void XmlNode::set_allocated_source(::aapt::pb::SourcePosition* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.source)
}

inline bool XmlNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void XmlNode::clear_has_node() {
  _impl_._oneof_case_[0] = NODE_NOT_SET;
}
inline XmlNode::NodeCase XmlNode::node_case() const {
  return XmlNode::NodeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// XmlElement

// repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
inline int XmlElement::_internal_namespace_declaration_size() const {
  return _impl_.namespace_declaration_.size();
}
inline int XmlElement::namespace_declaration_size() const {
  return _internal_namespace_declaration_size();
}
inline void XmlElement::clear_namespace_declaration() {
  _impl_.namespace_declaration_.Clear();
}
inline ::aapt::pb::XmlNamespace* XmlElement::mutable_namespace_declaration(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_declaration)
  return _impl_.namespace_declaration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
XmlElement::mutable_namespace_declaration() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.namespace_declaration)
  return &_impl_.namespace_declaration_;
}
inline const ::aapt::pb::XmlNamespace& XmlElement::_internal_namespace_declaration(int index) const {
  return _impl_.namespace_declaration_.Get(index);
}
inline const ::aapt::pb::XmlNamespace& XmlElement::namespace_declaration(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_declaration)
  return _internal_namespace_declaration(index);
}
inline ::aapt::pb::XmlNamespace* XmlElement::_internal_add_namespace_declaration() {
  return _impl_.namespace_declaration_.Add();
}
inline ::aapt::pb::XmlNamespace* XmlElement::add_namespace_declaration() {
  ::aapt::pb::XmlNamespace* _add = _internal_add_namespace_declaration();
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.namespace_declaration)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
XmlElement::namespace_declaration() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.namespace_declaration)
  return _impl_.namespace_declaration_;
}

// string namespace_uri = 2;
inline void XmlElement::clear_namespace_uri() {
  _impl_.namespace_uri_.ClearToEmpty();
}
inline const std::string& XmlElement::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_uri)
  return _internal_namespace_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlElement::set_namespace_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.namespace_uri)
}
inline std::string* XmlElement::mutable_namespace_uri() {
  std::string* _s = _internal_mutable_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_uri)
  return _s;
}
inline const std::string& XmlElement::_internal_namespace_uri() const {
  return _impl_.namespace_uri_.Get();
}
inline void XmlElement::_internal_set_namespace_uri(const std::string& value) {
  
  _impl_.namespace_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlElement::_internal_mutable_namespace_uri() {
  
  return _impl_.namespace_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlElement::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.namespace_uri)
  return _impl_.namespace_uri_.Release();
}
inline void XmlElement::set_allocated_namespace_uri(std::string* namespace_uri) {
  _impl_.namespace_uri_.SetAllocated(namespace_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace_uri_.IsDefault()) {
    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.namespace_uri)
}

// string name = 3;
inline void XmlElement::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& XmlElement::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlElement::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.name)
}
inline std::string* XmlElement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.name)
  return _s;
}
inline const std::string& XmlElement::_internal_name() const {
  return _impl_.name_.Get();
}
inline void XmlElement::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlElement::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlElement::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.name)
  return _impl_.name_.Release();
}
inline void XmlElement::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.name)
}

// repeated .aapt.pb.XmlAttribute attribute = 4;
inline int XmlElement::_internal_attribute_size() const {
  return _impl_.attribute_.size();
}
inline int XmlElement::attribute_size() const {
  return _internal_attribute_size();
}
inline void XmlElement::clear_attribute() {
  _impl_.attribute_.Clear();
}
inline ::aapt::pb::XmlAttribute* XmlElement::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.attribute)
  return _impl_.attribute_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
XmlElement::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.attribute)
  return &_impl_.attribute_;
}
inline const ::aapt::pb::XmlAttribute& XmlElement::_internal_attribute(int index) const {
  return _impl_.attribute_.Get(index);
}
inline const ::aapt::pb::XmlAttribute& XmlElement::attribute(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.attribute)
  return _internal_attribute(index);
}
inline ::aapt::pb::XmlAttribute* XmlElement::_internal_add_attribute() {
  return _impl_.attribute_.Add();
}
inline ::aapt::pb::XmlAttribute* XmlElement::add_attribute() {
  ::aapt::pb::XmlAttribute* _add = _internal_add_attribute();
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.attribute)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
XmlElement::attribute() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.attribute)
  return _impl_.attribute_;
}

// repeated .aapt.pb.XmlNode child = 5;
inline int XmlElement::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int XmlElement::child_size() const {
  return _internal_child_size();
}
inline void XmlElement::clear_child() {
  _impl_.child_.Clear();
}
inline ::aapt::pb::XmlNode* XmlElement::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >*
XmlElement::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.child)
  return &_impl_.child_;
}
inline const ::aapt::pb::XmlNode& XmlElement::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::aapt::pb::XmlNode& XmlElement::child(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.child)
  return _internal_child(index);
}
inline ::aapt::pb::XmlNode* XmlElement::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::aapt::pb::XmlNode* XmlElement::add_child() {
  ::aapt::pb::XmlNode* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >&
XmlElement::child() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.child)
  return _impl_.child_;
}

// -------------------------------------------------------------------

// XmlNamespace

// string prefix = 1;
inline void XmlNamespace::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& XmlNamespace::prefix() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlNamespace::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.prefix)
}
inline std::string* XmlNamespace::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.prefix)
  return _s;
}
inline const std::string& XmlNamespace::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void XmlNamespace::_internal_set_prefix(const std::string& value) {
  
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlNamespace::_internal_mutable_prefix() {
  
  return _impl_.prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlNamespace::release_prefix() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.prefix)
  return _impl_.prefix_.Release();
}
inline void XmlNamespace::set_allocated_prefix(std::string* prefix) {
  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.prefix)
}

// string uri = 2;
inline void XmlNamespace::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& XmlNamespace::uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlNamespace::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.uri)
}
inline std::string* XmlNamespace::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.uri)
  return _s;
}
inline const std::string& XmlNamespace::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void XmlNamespace::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlNamespace::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlNamespace::release_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.uri)
  return _impl_.uri_.Release();
}
inline void XmlNamespace::set_allocated_uri(std::string* uri) {
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.uri)
}

// .aapt.pb.SourcePosition source = 3;
inline bool XmlNamespace::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool XmlNamespace::has_source() const {
  return _internal_has_source();
}
inline void XmlNamespace::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::SourcePosition& XmlNamespace::_internal_source() const {
  const ::aapt::pb::SourcePosition* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
      ::aapt::pb::_SourcePosition_default_instance_);
}
inline const ::aapt::pb::SourcePosition& XmlNamespace::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.source)
  return _internal_source();
}
inline void XmlNamespace::unsafe_arena_set_allocated_source(
    ::aapt::pb::SourcePosition* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNamespace.source)
}
inline ::aapt::pb::SourcePosition* XmlNamespace::release_source() {
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlNamespace::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.source)
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlNamespace::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::SourcePosition* XmlNamespace::mutable_source() {
  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.source)
  return _msg;
}
inline void XmlNamespace::set_allocated_source(::aapt::pb::SourcePosition* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.source)
}

// -------------------------------------------------------------------

// XmlAttribute

// string namespace_uri = 1;
inline void XmlAttribute::clear_namespace_uri() {
  _impl_.namespace_uri_.ClearToEmpty();
}
inline const std::string& XmlAttribute::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.namespace_uri)
  return _internal_namespace_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlAttribute::set_namespace_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.namespace_uri)
}
inline std::string* XmlAttribute::mutable_namespace_uri() {
  std::string* _s = _internal_mutable_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.namespace_uri)
  return _s;
}
inline const std::string& XmlAttribute::_internal_namespace_uri() const {
  return _impl_.namespace_uri_.Get();
}
inline void XmlAttribute::_internal_set_namespace_uri(const std::string& value) {
  
  _impl_.namespace_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlAttribute::_internal_mutable_namespace_uri() {
  
  return _impl_.namespace_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlAttribute::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.namespace_uri)
  return _impl_.namespace_uri_.Release();
}
inline void XmlAttribute::set_allocated_namespace_uri(std::string* namespace_uri) {
  _impl_.namespace_uri_.SetAllocated(namespace_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace_uri_.IsDefault()) {
    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.namespace_uri)
}

// string name = 2;
inline void XmlAttribute::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& XmlAttribute::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlAttribute::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.name)
}
inline std::string* XmlAttribute::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.name)
  return _s;
}
inline const std::string& XmlAttribute::_internal_name() const {
  return _impl_.name_.Get();
}
inline void XmlAttribute::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlAttribute::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlAttribute::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.name)
  return _impl_.name_.Release();
}
inline void XmlAttribute::set_allocated_name(std::string* name) {
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.name)
}

// string value = 3;
inline void XmlAttribute::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& XmlAttribute::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void XmlAttribute::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.value)
}
inline std::string* XmlAttribute::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.value)
  return _s;
}
inline const std::string& XmlAttribute::_internal_value() const {
  return _impl_.value_.Get();
}
inline void XmlAttribute::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* XmlAttribute::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* XmlAttribute::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.value)
  return _impl_.value_.Release();
}
inline void XmlAttribute::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.value)
}

// .aapt.pb.SourcePosition source = 4;
inline bool XmlAttribute::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool XmlAttribute::has_source() const {
  return _internal_has_source();
}
inline void XmlAttribute::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::aapt::pb::SourcePosition& XmlAttribute::_internal_source() const {
  const ::aapt::pb::SourcePosition* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
      ::aapt::pb::_SourcePosition_default_instance_);
}
inline const ::aapt::pb::SourcePosition& XmlAttribute::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.source)
  return _internal_source();
}
inline void XmlAttribute::unsafe_arena_set_allocated_source(
    ::aapt::pb::SourcePosition* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlAttribute.source)
}
inline ::aapt::pb::SourcePosition* XmlAttribute::release_source() {
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlAttribute::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.source)
  
  ::aapt::pb::SourcePosition* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::aapt::pb::SourcePosition* XmlAttribute::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::aapt::pb::SourcePosition* XmlAttribute::mutable_source() {
  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.source)
  return _msg;
}
inline void XmlAttribute::set_allocated_source(::aapt::pb::SourcePosition* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.source)
}

// uint32 resource_id = 5;
inline void XmlAttribute::clear_resource_id() {
  _impl_.resource_id_ = 0u;
}
inline ::uint32_t XmlAttribute::_internal_resource_id() const {
  return _impl_.resource_id_;
}
inline ::uint32_t XmlAttribute::resource_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.resource_id)
  return _internal_resource_id();
}
inline void XmlAttribute::_internal_set_resource_id(::uint32_t value) {
  
  _impl_.resource_id_ = value;
}
inline void XmlAttribute::set_resource_id(::uint32_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.resource_id)
}

// .aapt.pb.Item compiled_item = 6;
inline bool XmlAttribute::_internal_has_compiled_item() const {
  return this != internal_default_instance() && _impl_.compiled_item_ != nullptr;
}
inline bool XmlAttribute::has_compiled_item() const {
  return _internal_has_compiled_item();
}
inline void XmlAttribute::clear_compiled_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.compiled_item_ != nullptr) {
    delete _impl_.compiled_item_;
  }
  _impl_.compiled_item_ = nullptr;
}
inline const ::aapt::pb::Item& XmlAttribute::_internal_compiled_item() const {
  const ::aapt::pb::Item* p = _impl_.compiled_item_;
  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
      ::aapt::pb::_Item_default_instance_);
}
inline const ::aapt::pb::Item& XmlAttribute::compiled_item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.compiled_item)
  return _internal_compiled_item();
}
inline void XmlAttribute::unsafe_arena_set_allocated_compiled_item(
    ::aapt::pb::Item* compiled_item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compiled_item_);
  }
  _impl_.compiled_item_ = compiled_item;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlAttribute.compiled_item)
}
inline ::aapt::pb::Item* XmlAttribute::release_compiled_item() {
  
  ::aapt::pb::Item* temp = _impl_.compiled_item_;
  _impl_.compiled_item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aapt::pb::Item* XmlAttribute::unsafe_arena_release_compiled_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.compiled_item)
  
  ::aapt::pb::Item* temp = _impl_.compiled_item_;
  _impl_.compiled_item_ = nullptr;
  return temp;
}
inline ::aapt::pb::Item* XmlAttribute::_internal_mutable_compiled_item() {
  
  if (_impl_.compiled_item_ == nullptr) {
    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
    _impl_.compiled_item_ = p;
  }
  return _impl_.compiled_item_;
}
inline ::aapt::pb::Item* XmlAttribute::mutable_compiled_item() {
  ::aapt::pb::Item* _msg = _internal_mutable_compiled_item();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.compiled_item)
  return _msg;
}
inline void XmlAttribute::set_allocated_compiled_item(::aapt::pb::Item* compiled_item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compiled_item_;
  }
  if (compiled_item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compiled_item);
    if (message_arena != submessage_arena) {
      compiled_item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compiled_item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compiled_item_ = compiled_item;
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.compiled_item)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::aapt::pb::Visibility_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Visibility_Level>() {
  return ::aapt::pb::Visibility_Level_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::OverlayableItem_Policy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::OverlayableItem_Policy>() {
  return ::aapt::pb::OverlayableItem_Policy_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Reference_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Reference_Type>() {
  return ::aapt::pb::Reference_Type_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::FileReference_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::FileReference_Type>() {
  return ::aapt::pb::FileReference_Type_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Attribute_FormatFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Attribute_FormatFlags>() {
  return ::aapt::pb::Attribute_FormatFlags_descriptor();
}
template <> struct is_proto_enum< ::aapt::pb::Plural_Arity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Plural_Arity>() {
  return ::aapt::pb::Plural_Arity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto
